// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
	"github.com/sapslaj/mid/pkg/cast"
)

// Use this module to manage order of boot devices.
const IpmiBootName = "ipmi_boot"

// Set boot device to use on next reboot.
// The choices for the device are:
// `network` -- Request network boot.
// `floppy` -- Boot from floppy.
// `hd` -- Boot from hard drive.
// `safe` -- Boot from hard drive, requesting 'safe mode'.
// `optical` -- boot from CD/DVD/BD drive.
// `setup` -- Boot into setup utility.
// `default` -- remove any IPMI directed boot device request.
type IpmiBootBootdev string

const (
	IpmiBootBootdevNetwork IpmiBootBootdev = "network"
	IpmiBootBootdevFloppy  IpmiBootBootdev = "floppy"
	IpmiBootBootdevHd      IpmiBootBootdev = "hd"
	IpmiBootBootdevSafe    IpmiBootBootdev = "safe"
	IpmiBootBootdevOptical IpmiBootBootdev = "optical"
	IpmiBootBootdevSetup   IpmiBootBootdev = "setup"
	IpmiBootBootdevDefault IpmiBootBootdev = "default"
)

// Whether to ensure that boot devices is desired.
// The choices for the state are: - present -- Request system turn on - absent
// -- Request system turn on.
type IpmiBootState string

const (
	IpmiBootStatePresent IpmiBootState = "present"
	IpmiBootStateAbsent  IpmiBootState = "absent"
)

// Convert a supported type to an optional (pointer) IpmiBootState
func OptionalIpmiBootState[T interface {
	*IpmiBootState | IpmiBootState | *string | string
}](s T) *IpmiBootState {
	switch v := any(s).(type) {
	case *IpmiBootState:
		return v
	case IpmiBootState:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := IpmiBootState(*v)
		return &val
	case string:
		val := IpmiBootState(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `ipmi_boot` Ansible module.
type IpmiBootParameters struct {
	// Hostname or IP address of the BMC.
	Name string `json:"name"`

	// Remote RMCP port.
	// default: 623
	Port *int `json:"port,omitempty"`

	// Username to use to connect to the BMC.
	User string `json:"user"`

	// Password to connect to the BMC.
	Password string `json:"password"`

	// Encryption key to connect to the BMC in hex format.
	Key *string `json:"key,omitempty"`

	// Set boot device to use on next reboot.
	// The choices for the device are:
	// `network` -- Request network boot.
	// `floppy` -- Boot from floppy.
	// `hd` -- Boot from hard drive.
	// `safe` -- Boot from hard drive, requesting 'safe mode'.
	// `optical` -- boot from CD/DVD/BD drive.
	// `setup` -- Boot into setup utility.
	// `default` -- remove any IPMI directed boot device request.
	Bootdev IpmiBootBootdev `json:"bootdev"`

	// Whether to ensure that boot devices is desired.
	// The choices for the state are: - present -- Request system turn on - absent
	// -- Request system turn on.
	// default: IpmiBootStatePresent
	State *IpmiBootState `json:"state,omitempty"`

	// If set, ask that system firmware uses this device beyond next boot. Be aware
	// many systems do not honor this.
	// default: false
	Persistent *bool `json:"persistent,omitempty"`

	// If set, request UEFI boot explicitly. Strictly speaking, the spec suggests
	// that if not set, the system should BIOS boot and offers no "do not care"
	// option. In practice, this flag not being set does not preclude UEFI boot on
	// any system I have encountered.
	// default: false
	Uefiboot *bool `json:"uefiboot,omitempty"`
}

// Wrap the `IpmiBootParameters into an `rpc.RPCCall`.
func (p IpmiBootParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := cast.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: IpmiBootName,
			Args: args,
		},
	}, nil
}

// Return values for the `ipmi_boot` Ansible module.
type IpmiBootReturn struct {
	AnsibleCommonReturns

	// The boot device name which will be used beyond next boot.
	Bootdev *string `json:"bootdev,omitempty"`

	// If True, system firmware will use this device beyond next boot.
	Persistent *bool `json:"persistent,omitempty"`

	// If True, system firmware will use UEFI boot explicitly beyond next boot.
	Uefimode *bool `json:"uefimode,omitempty"`
}

// Unwrap the `rpc.RPCResult` into an `IpmiBootReturn`
func IpmiBootReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (IpmiBootReturn, error) {
	return cast.AnyToJSONT[IpmiBootReturn](r.Result.Result)
}
