// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
)

// Manage the network devices. Create, modify and manage various connection and
// device type, for example `ethernet`, `team`, `bond`, `vlan` and so on.
// On CentOS 8 and Fedora >=29 like systems, the requirements can be met by
// installing the following packages: NetworkManager.
// On CentOS 7 and Fedora <=28 like systems, the requirements can be met by
// installing the following packages: NetworkManager-tui.
// On Ubuntu and Debian like systems, the requirements can be met by installing
// the following packages: network-manager.
// On openSUSE, the requirements can be met by installing the following
// packages: NetworkManager.
const NmcliName = "nmcli"

// Whether the device should exist or not, taking action if the state is
// different from what is stated.
// Using `state=present` to create connection will automatically bring
// connection up.
// Using `state=up` and `state=down` will not modify connection with other
// parameters. These states have been added in community.general 9.5.0.
type NmcliState string

const (
	NmcliStateAbsent  NmcliState = "absent"
	NmcliStatePresent NmcliState = "present"
	NmcliStateUp      NmcliState = "up"
	NmcliStateDown    NmcliState = "down"
)

// This is the type of device or network connection that you wish to create or
// modify.
// Type `dummy` is added in community.general 3.5.0.
// Type `gsm` is added in community.general 3.7.0.
// Type `infiniband` is added in community.general 2.0.0.
// Type `loopback` is added in community.general 8.1.0.
// Type `macvlan` is added in community.general 6.6.0.
// Type `ovs-bridge` is added in community.general 8.6.0.
// Type `ovs-interface` is added in community.general 8.6.0.
// Type `ovs-port` is added in community.general 8.6.0.
// Type `wireguard` is added in community.general 4.3.0.
// Type `vpn` is added in community.general 5.1.0.
// Type `vrf` is added in community.general 10.4.0.
// Using `bond-slave`, `bridge-slave`, or `team-slave` implies `ethernet`
// connection type with corresponding `slave_type` option.
// If you want to control non-ethernet connection attached to `bond`, `bridge`,
// or `team` consider using `slave_type` option.
type NmcliType string

const (
	NmcliTypeBond         NmcliType = "bond"
	NmcliTypeBondSlave    NmcliType = "bond-slave"
	NmcliTypeBridge       NmcliType = "bridge"
	NmcliTypeBridgeSlave  NmcliType = "bridge-slave"
	NmcliTypeDummy        NmcliType = "dummy"
	NmcliTypeEthernet     NmcliType = "ethernet"
	NmcliTypeGeneric      NmcliType = "generic"
	NmcliTypeGre          NmcliType = "gre"
	NmcliTypeInfiniband   NmcliType = "infiniband"
	NmcliTypeIpip         NmcliType = "ipip"
	NmcliTypeMacvlan      NmcliType = "macvlan"
	NmcliTypeSit          NmcliType = "sit"
	NmcliTypeTeam         NmcliType = "team"
	NmcliTypeTeamSlave    NmcliType = "team-slave"
	NmcliTypeVlan         NmcliType = "vlan"
	NmcliTypeVxlan        NmcliType = "vxlan"
	NmcliTypeWifi         NmcliType = "wifi"
	NmcliTypeGsm          NmcliType = "gsm"
	NmcliTypeWireguard    NmcliType = "wireguard"
	NmcliTypeOvsBridge    NmcliType = "ovs-bridge"
	NmcliTypeOvsPort      NmcliType = "ovs-port"
	NmcliTypeOvsInterface NmcliType = "ovs-interface"
	NmcliTypeVpn          NmcliType = "vpn"
	NmcliTypeVrf          NmcliType = "vrf"
	NmcliTypeLoopback     NmcliType = "loopback"
)

// Convert a supported type to an optional (pointer) NmcliType
func OptionalNmcliType[T interface {
	*NmcliType | NmcliType | *string | string
}](s T) *NmcliType {
	switch v := any(s).(type) {
	case *NmcliType:
		return v
	case NmcliType:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := NmcliType(*v)
		return &val
	case string:
		val := NmcliType(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// This is the type of device or network connection that you wish to create for
// a bond or bridge.
type NmcliMode string

const (
	NmcliMode8023ad       NmcliMode = "802.3ad"
	NmcliModeActiveBackup NmcliMode = "active-backup"
	NmcliModeBalanceAlb   NmcliMode = "balance-alb"
	NmcliModeBalanceRr    NmcliMode = "balance-rr"
	NmcliModeBalanceTlb   NmcliMode = "balance-tlb"
	NmcliModeBalanceXor   NmcliMode = "balance-xor"
	NmcliModeBroadcast    NmcliMode = "broadcast"
)

// Convert a supported type to an optional (pointer) NmcliMode
func OptionalNmcliMode[T interface {
	*NmcliMode | NmcliMode | *string | string
}](s T) *NmcliMode {
	switch v := any(s).(type) {
	case *NmcliMode:
		return v
	case NmcliMode:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := NmcliMode(*v)
		return &val
	case string:
		val := NmcliMode(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// This option sets the connection type of Infiniband IPoIB devices.
type NmcliTransportMode string

const (
	NmcliTransportModeDatagram  NmcliTransportMode = "datagram"
	NmcliTransportModeConnected NmcliTransportMode = "connected"
)

// Convert a supported type to an optional (pointer) NmcliTransportMode
func OptionalNmcliTransportMode[T interface {
	*NmcliTransportMode | NmcliTransportMode | *string | string
}](s T) *NmcliTransportMode {
	switch v := any(s).(type) {
	case *NmcliTransportMode:
		return v
	case NmcliTransportMode:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := NmcliTransportMode(*v)
		return &val
	case string:
		val := NmcliTransportMode(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Type of the device of this slave's master connection (for example `bond`).
// Type `ovs-port` is added in community.general 8.6.0.
type NmcliSlaveType string

const (
	NmcliSlaveTypeBond    NmcliSlaveType = "bond"
	NmcliSlaveTypeBridge  NmcliSlaveType = "bridge"
	NmcliSlaveTypeTeam    NmcliSlaveType = "team"
	NmcliSlaveTypeOvsPort NmcliSlaveType = "ovs-port"
	NmcliSlaveTypeVrf     NmcliSlaveType = "vrf"
)

// Convert a supported type to an optional (pointer) NmcliSlaveType
func OptionalNmcliSlaveType[T interface {
	*NmcliSlaveType | NmcliSlaveType | *string | string
}](s T) *NmcliSlaveType {
	switch v := any(s).(type) {
	case *NmcliSlaveType:
		return v
	case NmcliSlaveType:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := NmcliSlaveType(*v)
		return &val
	case string:
		val := NmcliSlaveType(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Configuration method to be used for IPv4.
// If `ip4` is set, `ipv4.method` is automatically set to `manual` and this
// parameter is not needed.
type NmcliMethod4 string

const (
	NmcliMethod4Auto      NmcliMethod4 = "auto"
	NmcliMethod4LinkLocal NmcliMethod4 = "link-local"
	NmcliMethod4Manual    NmcliMethod4 = "manual"
	NmcliMethod4Shared    NmcliMethod4 = "shared"
	NmcliMethod4Disabled  NmcliMethod4 = "disabled"
)

// Convert a supported type to an optional (pointer) NmcliMethod4
func OptionalNmcliMethod4[T interface {
	*NmcliMethod4 | NmcliMethod4 | *string | string
}](s T) *NmcliMethod4 {
	switch v := any(s).(type) {
	case *NmcliMethod4:
		return v
	case NmcliMethod4:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := NmcliMethod4(*v)
		return &val
	case string:
		val := NmcliMethod4(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Configuration method to be used for IPv6.
// If `ip6` is set, `ipv6.method` is automatically set to `manual` and this
// parameter is not needed.
// `disabled` was added in community.general 3.3.0.
type NmcliMethod6 string

const (
	NmcliMethod6Ignore    NmcliMethod6 = "ignore"
	NmcliMethod6Auto      NmcliMethod6 = "auto"
	NmcliMethod6Dhcp      NmcliMethod6 = "dhcp"
	NmcliMethod6LinkLocal NmcliMethod6 = "link-local"
	NmcliMethod6Manual    NmcliMethod6 = "manual"
	NmcliMethod6Shared    NmcliMethod6 = "shared"
	NmcliMethod6Disabled  NmcliMethod6 = "disabled"
)

// Convert a supported type to an optional (pointer) NmcliMethod6
func OptionalNmcliMethod6[T interface {
	*NmcliMethod6 | NmcliMethod6 | *string | string
}](s T) *NmcliMethod6 {
	switch v := any(s).(type) {
	case *NmcliMethod6:
		return v
	case NmcliMethod6:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := NmcliMethod6(*v)
		return &val
	case string:
		val := NmcliMethod6(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// If enabled, it makes the kernel generate a temporary IPv6 address in addition
// to the public one.
type NmcliIpPrivacy6 string

const (
	NmcliIpPrivacy6Disabled         NmcliIpPrivacy6 = "disabled"
	NmcliIpPrivacy6PreferPublicAddr NmcliIpPrivacy6 = "prefer-public-addr"
	NmcliIpPrivacy6PreferTempAddr   NmcliIpPrivacy6 = "prefer-temp-addr"
	NmcliIpPrivacy6Unknown          NmcliIpPrivacy6 = "unknown"
)

// Convert a supported type to an optional (pointer) NmcliIpPrivacy6
func OptionalNmcliIpPrivacy6[T interface {
	*NmcliIpPrivacy6 | NmcliIpPrivacy6 | *string | string
}](s T) *NmcliIpPrivacy6 {
	switch v := any(s).(type) {
	case *NmcliIpPrivacy6:
		return v
	case NmcliIpPrivacy6:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := NmcliIpPrivacy6(*v)
		return &val
	case string:
		val := NmcliIpPrivacy6(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Configure method for creating the address for use with IPv6 Stateless Address
// Autoconfiguration.
// `default` and `default-or-eui64` have been added in community.general 6.5.0.
type NmcliAddrGenMode6 string

const (
	NmcliAddrGenMode6Default        NmcliAddrGenMode6 = "default"
	NmcliAddrGenMode6DefaultOrEui64 NmcliAddrGenMode6 = "default-or-eui64"
	NmcliAddrGenMode6Eui64          NmcliAddrGenMode6 = "eui64"
	NmcliAddrGenMode6StablePrivacy  NmcliAddrGenMode6 = "stable-privacy"
)

// Convert a supported type to an optional (pointer) NmcliAddrGenMode6
func OptionalNmcliAddrGenMode6[T interface {
	*NmcliAddrGenMode6 | NmcliAddrGenMode6 | *string | string
}](s T) *NmcliAddrGenMode6 {
	switch v := any(s).(type) {
	case *NmcliAddrGenMode6:
		return v
	case NmcliAddrGenMode6:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := NmcliAddrGenMode6(*v)
		return &val
	case string:
		val := NmcliAddrGenMode6(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// This is only used with bond - fail_over_mac.
type NmcliFailOverMac string

const (
	NmcliFailOverMacNone   NmcliFailOverMac = "none"
	NmcliFailOverMacActive NmcliFailOverMac = "active"
	NmcliFailOverMacFollow NmcliFailOverMac = "follow"
)

// Convert a supported type to an optional (pointer) NmcliFailOverMac
func OptionalNmcliFailOverMac[T interface {
	*NmcliFailOverMac | NmcliFailOverMac | *string | string
}](s T) *NmcliFailOverMac {
	switch v := any(s).(type) {
	case *NmcliFailOverMac:
		return v
	case NmcliFailOverMac:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := NmcliFailOverMac(*v)
		return &val
	case string:
		val := NmcliFailOverMac(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// This is the type of device or network connection that you wish to create for
// a team.
type NmcliRunner string

const (
	NmcliRunnerBroadcast    NmcliRunner = "broadcast"
	NmcliRunnerRoundrobin   NmcliRunner = "roundrobin"
	NmcliRunnerActivebackup NmcliRunner = "activebackup"
	NmcliRunnerLoadbalance  NmcliRunner = "loadbalance"
	NmcliRunnerLacp         NmcliRunner = "lacp"
)

// Convert a supported type to an optional (pointer) NmcliRunner
func OptionalNmcliRunner[T interface {
	*NmcliRunner | NmcliRunner | *string | string
}](s T) *NmcliRunner {
	switch v := any(s).(type) {
	case *NmcliRunner:
		return v
	case NmcliRunner:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := NmcliRunner(*v)
		return &val
	case string:
		val := NmcliRunner(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// This defines the policy of how hardware addresses of team device and port
// devices should be set during the team lifetime.
type NmcliRunnerHwaddrPolicy string

const (
	NmcliRunnerHwaddrPolicySameAll    NmcliRunnerHwaddrPolicy = "same_all"
	NmcliRunnerHwaddrPolicyByActive   NmcliRunnerHwaddrPolicy = "by_active"
	NmcliRunnerHwaddrPolicyOnlyActive NmcliRunnerHwaddrPolicy = "only_active"
)

// Convert a supported type to an optional (pointer) NmcliRunnerHwaddrPolicy
func OptionalNmcliRunnerHwaddrPolicy[T interface {
	*NmcliRunnerHwaddrPolicy | NmcliRunnerHwaddrPolicy | *string | string
}](s T) *NmcliRunnerHwaddrPolicy {
	switch v := any(s).(type) {
	case *NmcliRunnerHwaddrPolicy:
		return v
	case NmcliRunnerHwaddrPolicy:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := NmcliRunnerHwaddrPolicy(*v)
		return &val
	case string:
		val := NmcliRunnerHwaddrPolicy(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `nmcli` Ansible module.
type NmcliParameters struct {
	// Whether the device should exist or not, taking action if the state is
	// different from what is stated.
	// Using `state=present` to create connection will automatically bring
	// connection up.
	// Using `state=up` and `state=down` will not modify connection with other
	// parameters. These states have been added in community.general 9.5.0.
	State NmcliState `json:"state"`

	// Whether the connection should start on boot.
	// Whether the connection profile can be automatically activated.
	// default: true
	Autoconnect *bool `json:"autoconnect,omitempty"`

	// The name used to call the connection. Pattern is
	// `<type>[-<ifname>][-<num>]`.
	ConnName string `json:"conn_name"`

	// Whether the connection should be reloaded if it was modified.
	// default: false
	ConnReload *bool `json:"conn_reload,omitempty"`

	// The interface to bind the connection to.
	// The connection will only be applicable to this interface name.
	// A special value of `*` can be used for interface-independent connections.
	// The ifname argument is mandatory for all connection types except bond, team,
	// bridge, vlan and vpn.
	// This parameter defaults to `conn_name` when left unset for all connection
	// types except vpn that removes it.
	Ifname *string `json:"ifname,omitempty"`

	// This is the type of device or network connection that you wish to create or
	// modify.
	// Type `dummy` is added in community.general 3.5.0.
	// Type `gsm` is added in community.general 3.7.0.
	// Type `infiniband` is added in community.general 2.0.0.
	// Type `loopback` is added in community.general 8.1.0.
	// Type `macvlan` is added in community.general 6.6.0.
	// Type `ovs-bridge` is added in community.general 8.6.0.
	// Type `ovs-interface` is added in community.general 8.6.0.
	// Type `ovs-port` is added in community.general 8.6.0.
	// Type `wireguard` is added in community.general 4.3.0.
	// Type `vpn` is added in community.general 5.1.0.
	// Type `vrf` is added in community.general 10.4.0.
	// Using `bond-slave`, `bridge-slave`, or `team-slave` implies `ethernet`
	// connection type with corresponding `slave_type` option.
	// If you want to control non-ethernet connection attached to `bond`, `bridge`,
	// or `team` consider using `slave_type` option.
	Type *NmcliType `json:"type,omitempty"`

	// This is the type of device or network connection that you wish to create for
	// a bond or bridge.
	// default: NmcliModeBalanceRr
	Mode *NmcliMode `json:"mode,omitempty"`

	// This option sets the connection type of Infiniband IPoIB devices.
	TransportMode *NmcliTransportMode `json:"transport_mode,omitempty"`

	// MAC address of the Infiniband IPoIB devices.
	InfinibandMac *string `json:"infiniband_mac,omitempty"`

	// Type of the device of this slave's master connection (for example `bond`).
	// Type `ovs-port` is added in community.general 8.6.0.
	SlaveType *NmcliSlaveType `json:"slave_type,omitempty"`

	// Master <master (ifname, or connection UUID or conn_name) of bridge, team,
	// bond, ovs-port master connection profile.
	// Mandatory if `slave_type` is defined.
	Master *string `json:"master,omitempty"`

	// List of IPv4 addresses to this interface.
	// Use the format `192.0.2.24/24` or `192.0.2.24`.
	// If defined and `method4` is not specified, automatically set `ipv4.method`
	// to `manual`.
	Ip4 *[]string `json:"ip4,omitempty"`

	// The IPv4 gateway for this interface.
	// Use the format `192.0.2.1`.
	// This parameter is mutually_exclusive with never_default4 parameter.
	Gw4 *string `json:"gw4,omitempty"`

	// Ignore automatically configured IPv4 routes.
	// default: false
	Gw4IgnoreAuto *bool `json:"gw4_ignore_auto,omitempty"`

	// The list of IPv4 routes.
	// Use the format `192.0.3.0/24 192.0.2.1`.
	// To specify more complex routes, use the `routes4_extended` option.
	Routes4 *[]string `json:"routes4,omitempty"`

	// The list of IPv4 routes.
	Routes4Extended *struct {
		Ip      string  `json:"ip"`
		NextHop *string `json:"next_hop,omitempty"`
		Metric  *int    `json:"metric,omitempty"`
		Table   *int    `json:"table,omitempty"`
		Cwnd    *int    `json:"cwnd,omitempty"`
		Mtu     *int    `json:"mtu,omitempty"`
		Onlink  *bool   `json:"onlink,omitempty"`
		Tos     *int    `json:"tos,omitempty"`
	} `json:"routes4_extended,omitempty"`

	// Set metric level of ipv4 routes configured on interface.
	RouteMetric4 *int `json:"route_metric4,omitempty"`

	// Is the same as in an `ip rule add` command, except always requires
	// specifying a priority.
	RoutingRules4 *[]string `json:"routing_rules4,omitempty"`

	// Set as default route.
	// This parameter is mutually_exclusive with gw4 parameter.
	// default: false
	NeverDefault4 *bool `json:"never_default4,omitempty"`

	// A list of up to 3 DNS servers.
	// The entries must be IPv4 addresses, for example `192.0.2.53`.
	Dns4 *[]string `json:"dns4,omitempty"`

	// A list of DNS search domains.
	Dns4Search *[]string `json:"dns4_search,omitempty"`

	// A list of DNS options.
	Dns4Options *[]string `json:"dns4_options,omitempty"`

	// Ignore automatically configured IPv4 name servers.
	// default: false
	Dns4IgnoreAuto *bool `json:"dns4_ignore_auto,omitempty"`

	// Configuration method to be used for IPv4.
	// If `ip4` is set, `ipv4.method` is automatically set to `manual` and this
	// parameter is not needed.
	Method4 *NmcliMethod4 `json:"method4,omitempty"`

	// If you need `ip4` configured before `network-online.target` is reached, set
	// this option to `false`.
	// This option applies when `method4` is not `disabled`.
	// default: true
	MayFail4 *bool `json:"may_fail4,omitempty"`

	// List of IPv6 addresses to this interface.
	// Use the format `abbe::cafe/128` or `abbe::cafe`.
	// If defined and `method6` is not specified, automatically set `ipv6.method`
	// to `manual`.
	Ip6 *[]string `json:"ip6,omitempty"`

	// The IPv6 gateway for this interface.
	// Use the format `2001:db8::1`.
	Gw6 *string `json:"gw6,omitempty"`

	// Ignore automatically configured IPv6 routes.
	// default: false
	Gw6IgnoreAuto *bool `json:"gw6_ignore_auto,omitempty"`

	// The list of IPv6 routes.
	// Use the format `fd12:3456:789a:1::/64 2001:dead:beef::1`.
	// To specify more complex routes, use the `routes6_extended` option.
	Routes6 *[]string `json:"routes6,omitempty"`

	// The list of IPv6 routes but with parameters.
	Routes6Extended *struct {
		Ip      string  `json:"ip"`
		NextHop *string `json:"next_hop,omitempty"`
		Metric  *int    `json:"metric,omitempty"`
		Table   *int    `json:"table,omitempty"`
		Cwnd    *int    `json:"cwnd,omitempty"`
		Mtu     *int    `json:"mtu,omitempty"`
		Onlink  *bool   `json:"onlink,omitempty"`
	} `json:"routes6_extended,omitempty"`

	// Set metric level of IPv6 routes configured on interface.
	RouteMetric6 *int `json:"route_metric6,omitempty"`

	// A list of up to 3 DNS servers.
	// The entries must be IPv6 addresses, for example `2001:4860:4860::8888`.
	Dns6 *[]string `json:"dns6,omitempty"`

	// A list of DNS search domains.
	Dns6Search *[]string `json:"dns6_search,omitempty"`

	// A list of DNS options.
	Dns6Options *[]string `json:"dns6_options,omitempty"`

	// Ignore automatically configured IPv6 name servers.
	// default: false
	Dns6IgnoreAuto *bool `json:"dns6_ignore_auto,omitempty"`

	// Configuration method to be used for IPv6.
	// If `ip6` is set, `ipv6.method` is automatically set to `manual` and this
	// parameter is not needed.
	// `disabled` was added in community.general 3.3.0.
	Method6 *NmcliMethod6 `json:"method6,omitempty"`

	// If enabled, it makes the kernel generate a temporary IPv6 address in
	// addition to the public one.
	IpPrivacy6 *NmcliIpPrivacy6 `json:"ip_privacy6,omitempty"`

	// Configure method for creating the address for use with IPv6 Stateless
	// Address Autoconfiguration.
	// `default` and `default-or-eui64` have been added in community.general 6.5.0.
	AddrGenMode6 *NmcliAddrGenMode6 `json:"addr_gen_mode6,omitempty"`

	// The connection MTU, for example `9000`. This can not be applied when
	// creating the interface and is done once the interface has been created.
	// Can be used when modifying Team, VLAN, Ethernet (Future plans to implement
	// wifi, gsm, pppoe, infiniband).
	// This parameter defaults to `1500` when unset.
	Mtu *int `json:"mtu,omitempty"`

	// DHCP Client Identifier sent to the DHCP server.
	DhcpClientId *string `json:"dhcp_client_id,omitempty"`

	// This is only used with bond and is the primary interface name (for "active-
	// backup" mode), this is the usually the 'ifname'.
	Primary *string `json:"primary,omitempty"`

	// This is only used with bond - miimon.
	// This parameter defaults to `100` when unset.
	Miimon *int `json:"miimon,omitempty"`

	// This is only used with bond - downdelay.
	Downdelay *int `json:"downdelay,omitempty"`

	// This is only used with bond - updelay.
	Updelay *int `json:"updelay,omitempty"`

	// This is only used with bond - xmit_hash_policy type.
	XmitHashPolicy *string `json:"xmit_hash_policy,omitempty"`

	// This is only used with bond - fail_over_mac.
	FailOverMac *NmcliFailOverMac `json:"fail_over_mac,omitempty"`

	// This is only used with bond - ARP interval.
	ArpInterval *int `json:"arp_interval,omitempty"`

	// This is only used with bond - ARP IP target.
	ArpIpTarget *string `json:"arp_ip_target,omitempty"`

	// This is only used with bridge and controls whether Spanning Tree Protocol
	// (STP) is enabled for this bridge.
	// default: true
	Stp *bool `json:"stp,omitempty"`

	// This is only used with 'bridge' - sets STP priority.
	// default: 128
	Priority *int `json:"priority,omitempty"`

	// This is only used with bridge - [forward-delay <2-30>] STP forwarding delay,
	// in seconds.
	// default: 15
	Forwarddelay *int `json:"forwarddelay,omitempty"`

	// This is only used with bridge - [hello-time <1-10>] STP hello time, in
	// seconds.
	// default: 2
	Hellotime *int `json:"hellotime,omitempty"`

	// This is only used with bridge - [max-age <6-42>] STP maximum message age, in
	// seconds.
	// default: 20
	Maxage *int `json:"maxage,omitempty"`

	// This is only used with bridge - [ageing-time <0-1000000>] the Ethernet MAC
	// address aging time, in seconds.
	// default: 300
	Ageingtime *int `json:"ageingtime,omitempty"`

	// MAC address of the connection.
	// Note this requires a recent kernel feature, originally introduced in 3.15
	// upstream kernel.
	Mac *string `json:"mac,omitempty"`

	// This is only used with 'bridge-slave' - [<0-63>] - STP priority of this
	// slave.
	// default: 32
	Slavepriority *int `json:"slavepriority,omitempty"`

	// This is only used with 'bridge-slave' - [<1-65535>] - STP port cost for
	// destinations using this slave.
	// default: 100
	PathCost *int `json:"path_cost,omitempty"`

	// This is only used with 'bridge-slave' - 'hairpin mode' for the slave, which
	// allows frames to be sent back out through the slave the frame was received
	// on.
	// The default change to `false` in community.general 7.0.0. It used to be
	// `true` before.
	// default: false
	Hairpin *bool `json:"hairpin,omitempty"`

	// This is the type of device or network connection that you wish to create for
	// a team.
	// default: NmcliRunnerRoundrobin
	Runner *NmcliRunner `json:"runner,omitempty"`

	// This defines the policy of how hardware addresses of team device and port
	// devices should be set during the team lifetime.
	RunnerHwaddrPolicy *NmcliRunnerHwaddrPolicy `json:"runner_hwaddr_policy,omitempty"`

	// Option specifies the rate at which our link partner is asked to transmit
	// LACPDU packets. If this is `true` then packets will be sent once per second.
	// Otherwise they will be sent every 30 seconds.
	// Only allowed for `runner=lacp`.
	RunnerFastRate *bool `json:"runner_fast_rate,omitempty"`

	// This is only used with VLAN - VLAN ID in range <0-4095>.
	Vlanid *int `json:"vlanid,omitempty"`

	// This is only used with VLAN - parent device this VLAN is on, can use ifname.
	Vlandev *string `json:"vlandev,omitempty"`

	// This is only used with VLAN - flags.
	Flags *string `json:"flags,omitempty"`

	// This is only used with VLAN - VLAN ingress priority mapping.
	Ingress *string `json:"ingress,omitempty"`

	// This is only used with VLAN - VLAN egress priority mapping.
	Egress *string `json:"egress,omitempty"`

	// This is only used with VXLAN - VXLAN ID.
	VxlanId *int `json:"vxlan_id,omitempty"`

	// This is only used with VXLAN - VXLAN destination IP address.
	VxlanRemote *string `json:"vxlan_remote,omitempty"`

	// This is only used with VXLAN - VXLAN local IP address.
	VxlanLocal *string `json:"vxlan_local,omitempty"`

	// This is used with GRE/IPIP/SIT - parent device this GRE/IPIP/SIT tunnel, can
	// use ifname.
	IpTunnelDev *string `json:"ip_tunnel_dev,omitempty"`

	// This is used with GRE/IPIP/SIT - GRE/IPIP/SIT destination IP address.
	IpTunnelRemote *string `json:"ip_tunnel_remote,omitempty"`

	// This is used with GRE/IPIP/SIT - GRE/IPIP/SIT local IP address.
	IpTunnelLocal *string `json:"ip_tunnel_local,omitempty"`

	// The key used for tunnel input packets.
	// Only used when `type=gre`.
	IpTunnelInputKey *string `json:"ip_tunnel_input_key,omitempty"`

	// The key used for tunnel output packets.
	// Only used when `type=gre`.
	IpTunnelOutputKey *string `json:"ip_tunnel_output_key,omitempty"`

	// This is only used with VRF - VRF table number.
	Table *int `json:"table,omitempty"`

	// The trust level of the connection.
	// When updating this property on a currently activated connection, the change
	// takes effect immediately.
	Zone *string `json:"zone,omitempty"`

	// The security configuration of the WiFi connection.
	// Note the list of suboption attributes may vary depending on which version of
	// NetworkManager/nmcli is installed on the host.
	// An up-to-date list of supported attributes can be found here:
	// `https://networkmanager.dev/docs/api/latest/settings-802-11-wireless-
	// security.html`.
	// For instance to use common WPA-PSK auth with a password: `{key-mgmt: wpa-
	// psk, psk: my_password}`.
	WifiSec *struct {
		AuthAlg           *string   `json:"auth-alg,omitempty"`
		Fils              *int      `json:"fils,omitempty"`
		Group             *[]string `json:"group,omitempty"`
		KeyMgmt           *string   `json:"key-mgmt,omitempty"`
		LeapPasswordFlags *[]int    `json:"leap-password-flags,omitempty"`
		LeapPassword      *string   `json:"leap-password,omitempty"`
		LeapUsername      *string   `json:"leap-username,omitempty"`
		Pairwise          *[]string `json:"pairwise,omitempty"`
		Pmf               *int      `json:"pmf,omitempty"`
		Proto             *[]string `json:"proto,omitempty"`
		PskFlags          *[]int    `json:"psk-flags,omitempty"`
		Psk               *string   `json:"psk,omitempty"`
		WepKeyFlags       *[]int    `json:"wep-key-flags,omitempty"`
		WepKeyType        *int      `json:"wep-key-type,omitempty"`
		WepKey0           *string   `json:"wep-key0,omitempty"`
		WepKey1           *string   `json:"wep-key1,omitempty"`
		WepKey2           *string   `json:"wep-key2,omitempty"`
		WepKey3           *string   `json:"wep-key3,omitempty"`
		WepTxKeyidx       *int      `json:"wep-tx-keyidx,omitempty"`
		WpsMethod         *int      `json:"wps-method,omitempty"`
	} `json:"wifi_sec,omitempty"`

	// Name of the Wireless router or the access point.
	Ssid *string `json:"ssid,omitempty"`

	// The configuration of the WiFi connection.
	// Note the list of suboption attributes may vary depending on which version of
	// NetworkManager/nmcli is installed on the host.
	// An up-to-date list of supported attributes can be found here:
	// `https://networkmanager.dev/docs/api/latest/settings-802-11-wireless.html`.
	// For instance to create a hidden AP mode WiFi connection: `{hidden: true,
	// mode: ap}`.
	Wifi *struct {
		ApIsolation             *int      `json:"ap-isolation,omitempty"`
		AssignedMacAddress      *string   `json:"assigned-mac-address,omitempty"`
		Band                    *string   `json:"band,omitempty"`
		Bssid                   *string   `json:"bssid,omitempty"`
		Channel                 *int      `json:"channel,omitempty"`
		ClonedMacAddress        *string   `json:"cloned-mac-address,omitempty"`
		GenerateMacAddressMask  *string   `json:"generate-mac-address-mask,omitempty"`
		Hidden                  *bool     `json:"hidden,omitempty"`
		MacAddressBlacklist     *[]string `json:"mac-address-blacklist,omitempty"`
		MacAddressRandomization *int      `json:"mac-address-randomization,omitempty"`
		MacAddress              *string   `json:"mac-address,omitempty"`
		Mode                    *string   `json:"mode,omitempty"`
		Mtu                     *int      `json:"mtu,omitempty"`
		Powersave               *int      `json:"powersave,omitempty"`
		Rate                    *int      `json:"rate,omitempty"`
		TxPower                 *int      `json:"tx-power,omitempty"`
		WakeOnWlan              *int      `json:"wake-on-wlan,omitempty"`
	} `json:"wifi,omitempty"`

	// Ignore suboptions which are invalid or unsupported by the version of
	// NetworkManager/nmcli installed on the host.
	// Only `wifi` and `wifi_sec` options are currently affected.
	// default: false
	IgnoreUnsupportedSuboptions *bool `json:"ignore_unsupported_suboptions,omitempty"`

	// The configuration of the GSM connection.
	// Note the list of suboption attributes may vary depending on which version of
	// NetworkManager/nmcli is installed on the host.
	// An up-to-date list of supported attributes can be found here:
	// `https://networkmanager.dev/docs/api/latest/settings-gsm.html`.
	// For instance to use apn, pin, username and password: `{apn: provider.apn,
	// pin: 1234, username: apn.username, password: apn.password}`.
	Gsm *struct {
		Apn           *string `json:"apn,omitempty"`
		AutoConfig    *bool   `json:"auto-config,omitempty"`
		DeviceId      *string `json:"device-id,omitempty"`
		HomeOnly      *bool   `json:"home-only,omitempty"`
		Mtu           *int    `json:"mtu,omitempty"`
		NetworkId     *string `json:"network-id,omitempty"`
		Number        *string `json:"number,omitempty"`
		Password      *string `json:"password,omitempty"`
		PasswordFlags *int    `json:"password-flags,omitempty"`
		Pin           *string `json:"pin,omitempty"`
		PinFlags      *int    `json:"pin-flags,omitempty"`
		SimId         *string `json:"sim-id,omitempty"`
		SimOperatorId *string `json:"sim-operator-id,omitempty"`
		Username      *string `json:"username,omitempty"`
	} `json:"gsm,omitempty"`

	// The configuration of the MAC VLAN connection.
	// Note the list of suboption attributes may vary depending on which version of
	// NetworkManager/nmcli is installed on the host.
	// An up-to-date list of supported attributes can be found here:
	// `https://networkmanager.dev/docs/api/latest/settings-macvlan.html`.
	Macvlan *struct {
		Mode        int    `json:"mode"`
		Parent      string `json:"parent"`
		Promiscuous *bool  `json:"promiscuous,omitempty"`
		Tap         *bool  `json:"tap,omitempty"`
	} `json:"macvlan,omitempty"`

	// The configuration of the Wireguard connection.
	// Note the list of suboption attributes may vary depending on which version of
	// NetworkManager/nmcli is installed on the host.
	// An up-to-date list of supported attributes can be found here:
	// `https://networkmanager.dev/docs/api/latest/settings-wireguard.html`.
	// For instance to configure a listen port: `{listen-port: 12345}`.
	Wireguard *struct {
		Fwmark              *int    `json:"fwmark,omitempty"`
		Ip4AutoDefaultRoute *bool   `json:"ip4-auto-default-route,omitempty"`
		Ip6AutoDefaultRoute *bool   `json:"ip6-auto-default-route,omitempty"`
		ListenPort          *int    `json:"listen-port,omitempty"`
		Mtu                 *int    `json:"mtu,omitempty"`
		PeerRoutes          *bool   `json:"peer-routes,omitempty"`
		PrivateKey          *string `json:"private-key,omitempty"`
		PrivateKeyFlags     *int    `json:"private-key-flags,omitempty"`
	} `json:"wireguard,omitempty"`

	// Configuration of a VPN connection (PPTP and L2TP).
	// In order to use L2TP you need to be sure that `network-manager-l2tp` - and
	// `network-manager-l2tp-gnome` if host has UI - are installed on the host.
	Vpn *struct {
		Permissions   string  `json:"permissions"`
		ServiceType   string  `json:"service-type"`
		Gateway       string  `json:"gateway"`
		PasswordFlags *int    `json:"password-flags,omitempty"`
		User          string  `json:"user"`
		IpsecEnabled  *bool   `json:"ipsec-enabled,omitempty"`
		IpsecPsk      *string `json:"ipsec-psk,omitempty"`
	} `json:"vpn,omitempty"`

	// Allow to configure SR-IOV settings.
	// An up-to-date list of supported attributes can be found here: `https://netwo
	// rkmanager.pages.freedesktop.org/NetworkManager/NetworkManager/settings-
	// sriov.html`.
	Sriov *struct {
		AutoprobeDrivers  *int    `json:"autoprobe-drivers,omitempty"`
		EswitchEncapMode  *int    `json:"eswitch-encap-mode,omitempty"`
		EswitchInlineMode *int    `json:"eswitch-inline-mode,omitempty"`
		EswitchMode       *int    `json:"eswitch-mode,omitempty"`
		TotalVfs          *int    `json:"total-vfs,omitempty"`
		Vfs               *string `json:"vfs,omitempty"`
	} `json:"sriov,omitempty"`
}

// Wrap the `NmcliParameters into an `rpc.RPCCall`.
func (p NmcliParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := rpc.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: NmcliName,
			Args: args,
		},
	}, nil
}

// Return values for the `nmcli` Ansible module.
type NmcliReturn struct {
	AnsibleCommonReturns
}

// Unwrap the `rpc.RPCResult` into an `NmcliReturn`
func NmcliReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (NmcliReturn, error) {
	return rpc.AnyToJSONT[NmcliReturn](r.Result.Result)
}
