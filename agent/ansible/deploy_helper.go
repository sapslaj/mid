// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
	"github.com/sapslaj/mid/pkg/cast"
)

// The Deploy Helper manages some of the steps common in deploying software. It
// creates a folder structure, manages a symlink for the current release and
// cleans up old releases.
// Running it with the `state=query` or `state=present` will return the
// `deploy_helper` fact. `project_path`, whatever you set in the `path`
// parameter, `current_path`, the path to the symlink that points to the active
// release, `releases_path`, the path to the folder to keep releases in,
// `shared_path`, the path to the folder to keep shared resources in,
// `unfinished_filename`, the file to check for to recognize unfinished builds,
// `previous_release`, the release the 'current' symlink is pointing to,
// `previous_release_path`, the full path to the 'current' symlink target,
// `new_release`, either the `release` parameter or a generated timestamp,
// `new_release_path`, the path to the new release folder (not created by the
// module).
const DeployHelperName = "deploy_helper"

// The state of the project.
// `query` will only gather facts.
// `present` will create the project `root` folder, and in it the `releases` and
// `shared` folders.
// `finalize` will remove the unfinished_filename file, create a symlink to the
// newly deployed release and optionally clean old releases.
// `clean` will remove failed & old releases.
// `absent` will remove the project folder (synonymous to the
// `ansible.builtin.file` module with `state=absent`).
type DeployHelperState string

const (
	DeployHelperStatePresent  DeployHelperState = "present"
	DeployHelperStateFinalize DeployHelperState = "finalize"
	DeployHelperStateAbsent   DeployHelperState = "absent"
	DeployHelperStateClean    DeployHelperState = "clean"
	DeployHelperStateQuery    DeployHelperState = "query"
)

// Convert a supported type to an optional (pointer) DeployHelperState
func OptionalDeployHelperState[T interface {
	*DeployHelperState | DeployHelperState | *string | string
}](s T) *DeployHelperState {
	switch v := any(s).(type) {
	case *DeployHelperState:
		return v
	case DeployHelperState:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := DeployHelperState(*v)
		return &val
	case string:
		val := DeployHelperState(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `deploy_helper` Ansible module.
type DeployHelperParameters struct {
	// The root path of the project. Returned in the `deploy_helper.project_path`
	// fact.
	Path string `json:"path"`

	// The state of the project.
	// `query` will only gather facts.
	// `present` will create the project `root` folder, and in it the `releases`
	// and `shared` folders.
	// `finalize` will remove the unfinished_filename file, create a symlink to the
	// newly deployed release and optionally clean old releases.
	// `clean` will remove failed & old releases.
	// `absent` will remove the project folder (synonymous to the
	// `ansible.builtin.file` module with `state=absent`).
	// default: DeployHelperStatePresent
	State *DeployHelperState `json:"state,omitempty"`

	// The release version that is being deployed. Defaults to a timestamp format
	// `%Y%m%d%H%M%S` (for example `20141119223359`). This parameter is optional
	// during `state=present`, but needs to be set explicitly for `state=finalize`.
	// You can use the generated fact `release={{ deploy_helper.new_release }}`.
	Release *string `json:"release,omitempty"`

	// The name of the folder that will hold the releases. This can be relative to
	// `path` or absolute. Returned in the `deploy_helper.releases_path` fact.
	// default: "releases"
	ReleasesPath *string `json:"releases_path,omitempty"`

	// The name of the folder that will hold the shared resources. This can be
	// relative to `path` or absolute. If this is set to an empty string, no shared
	// folder will be created. Returned in the `deploy_helper.shared_path` fact.
	// default: "shared"
	SharedPath *string `json:"shared_path,omitempty"`

	// The name of the symlink that is created when the deploy is finalized. Used
	// in `state=finalize` and `state=clean`. Returned in the
	// `deploy_helper.current_path` fact.
	// default: "current"
	CurrentPath *string `json:"current_path,omitempty"`

	// The name of the file that indicates a deploy has not finished. All folders
	// in the `releases_path` that contain this file will be deleted on
	// `state=finalize` with `clean=true`, or `state=clean`. This file is
	// automatically deleted from the `new_release_path` during `state=finalize`.
	// default: "DEPLOY_UNFINISHED"
	UnfinishedFilename *string `json:"unfinished_filename,omitempty"`

	// Whether to run the clean procedure in case of `state=finalize`.
	// default: true
	Clean *bool `json:"clean,omitempty"`

	// The number of old releases to keep when cleaning. Used in `state=finalize`
	// and `state=clean`. Any unfinished builds will be deleted first, so only
	// correct releases will count. The current version will not count.
	// default: 5
	KeepReleases *int `json:"keep_releases,omitempty"`

	// The permissions the resulting filesystem object should have.
	// For those used to `/usr/bin/chmod` remember that modes are actually octal
	// numbers. You must give Ansible enough information to parse them correctly.
	// For consistent results, quote octal numbers (for example, `'644'` or
	// `'1777'`) so Ansible receives a string and can do its own conversion from
	// string into number. Adding a leading zero (for example, `0755`) works
	// sometimes, but can fail in loops and some other circumstances.
	// Giving Ansible a number without following either of these rules will end up
	// with a decimal number which will have unexpected results.
	// As of Ansible 1.8, the mode may be specified as a symbolic mode (for
	// example, `u+rwx` or `u=rw,g=r,o=r`).
	// If `mode` is not specified and the destination filesystem object `does not`
	// exist, the default `umask` on the system will be used when setting the mode
	// for the newly created filesystem object.
	// If `mode` is not specified and the destination filesystem object `does`
	// exist, the mode of the existing filesystem object will be used.
	// Specifying `mode` is the best way to ensure filesystem objects are created
	// with the correct permissions. See CVE-2020-1736 for further details.
	Mode *any `json:"mode,omitempty"`

	// Name of the user that should own the filesystem object, as would be fed to
	// `chown`.
	// When left unspecified, it uses the current user unless you are root, in
	// which case it can preserve the previous ownership.
	// Specifying a numeric username will be assumed to be a user ID and not a
	// username. Avoid numeric usernames to avoid this confusion.
	Owner *string `json:"owner,omitempty"`

	// Name of the group that should own the filesystem object, as would be fed to
	// `chown`.
	// When left unspecified, it uses the current group of the current user unless
	// you are root, in which case it can preserve the previous ownership.
	Group *string `json:"group,omitempty"`

	// The user part of the SELinux filesystem object context.
	// By default it uses the `system` policy, where applicable.
	// When set to `_default`, it will use the `user` portion of the policy if
	// available.
	Seuser *string `json:"seuser,omitempty"`

	// The role part of the SELinux filesystem object context.
	// When set to `_default`, it will use the `role` portion of the policy if
	// available.
	Serole *string `json:"serole,omitempty"`

	// The type part of the SELinux filesystem object context.
	// When set to `_default`, it will use the `type` portion of the policy if
	// available.
	Setype *string `json:"setype,omitempty"`

	// The level part of the SELinux filesystem object context.
	// This is the MLS/MCS attribute, sometimes known as the `range`.
	// When set to `_default`, it will use the `level` portion of the policy if
	// available.
	Selevel *string `json:"selevel,omitempty"`

	// Influence when to use atomic operation to prevent data corruption or
	// inconsistent reads from the target filesystem object.
	// By default this module uses atomic operations to prevent data corruption or
	// inconsistent reads from the target filesystem objects, but sometimes systems
	// are configured or just broken in ways that prevent this. One example is
	// docker mounted filesystem objects, which cannot be updated atomically from
	// inside the container and can only be written in an unsafe manner.
	// This option allows Ansible to fall back to unsafe methods of updating
	// filesystem objects when atomic operations fail (however, it doesn't force
	// Ansible to perform unsafe writes).
	// IMPORTANT! Unsafe writes are subject to race conditions and can lead to data
	// corruption.
	// default: false
	UnsafeWrites *bool `json:"unsafe_writes,omitempty"`

	// The attributes the resulting filesystem object should have.
	// To get supported flags look at the man page for `chattr` on the target
	// system.
	// This string should contain the attributes in the same order as the one
	// displayed by `lsattr`.
	// The `=` operator is assumed as default, otherwise `+` or `-` operators need
	// to be included in the string.
	Attributes *string `json:"attributes,omitempty"`
}

// Wrap the `DeployHelperParameters into an `rpc.RPCCall`.
func (p DeployHelperParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := cast.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: DeployHelperName,
			Args: args,
		},
	}, nil
}

// Return values for the `deploy_helper` Ansible module.
type DeployHelperReturn struct {
	AnsibleCommonReturns
}

// Unwrap the `rpc.RPCResult` into an `DeployHelperReturn`
func DeployHelperReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (DeployHelperReturn, error) {
	return cast.AnyToJSONT[DeployHelperReturn](r.Result.Result)
}
