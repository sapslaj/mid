// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
)

// Allows users to add or remove flatpaks.
// See the `community.general.flatpak_remote` module for managing flatpak
// remotes.
const FlatpakName = "flatpak"

// The installation method to use.
// Defines if the `flatpak` is supposed to be installed globally for the whole
// `system` or only for the current `user`.
type FlatpakMethod string

const (
	FlatpakMethodSystem FlatpakMethod = "system"
	FlatpakMethodUser   FlatpakMethod = "user"
)

func OptionalFlatpakMethod[T interface {
	*FlatpakMethod | FlatpakMethod | *string | string
}](s T) *FlatpakMethod {
	switch v := any(s).(type) {
	case *FlatpakMethod:
		return v
	case FlatpakMethod:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := FlatpakMethod(*v)
		return &val
	case string:
		val := FlatpakMethod(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Indicates the desired package state.
// The value `latest` is supported since community.general 8.6.0.
type FlatpakState string

const (
	FlatpakStateAbsent  FlatpakState = "absent"
	FlatpakStatePresent FlatpakState = "present"
	FlatpakStateLatest  FlatpakState = "latest"
)

func OptionalFlatpakState[T interface {
	*FlatpakState | FlatpakState | *string | string
}](s T) *FlatpakState {
	switch v := any(s).(type) {
	case *FlatpakState:
		return v
	case FlatpakState:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := FlatpakState(*v)
		return &val
	case string:
		val := FlatpakState(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `flatpak` Ansible module.
type FlatpakParameters struct {
	// The path to the `flatpak` executable to use.
	// By default, this module looks for the `flatpak` executable on the path.
	// default: "flatpak"
	Executable *string `json:"executable,omitempty"`

	// The installation method to use.
	// Defines if the `flatpak` is supposed to be installed globally for the whole
	// `system` or only for the current `user`.
	// default: FlatpakMethodSystem
	Method *FlatpakMethod `json:"method,omitempty"`

	// The name of the flatpak to manage. To operate on several packages this can
	// accept a list of packages.
	// When used with `state=present`, `name` can be specified as a URL to a
	// `flatpakref` file or the unique reverse DNS name that identifies a flatpak.
	// Both `https://` and `http://` URLs are supported.
	// When supplying a reverse DNS name, you can use the `remote` option to
	// specify on what remote to look for the flatpak. An example for a reverse DNS
	// name is `org.gnome.gedit`.
	// When used with `state=absent` or `state=latest`, it is recommended to
	// specify the name in the reverse DNS format.
	// When supplying a URL with `state=absent` or `state=latest`, the module will
	// try to match the installed flatpak based on the name of the flatpakref to
	// remove or update it. However, there is no guarantee that the names of the
	// flatpakref file and the reverse DNS name of the installed flatpak do match.
	Name []string `json:"name"`

	// If installing runtime dependencies should be omitted or not.
	// This parameter is primarily implemented for integration testing this module.
	// There might however be some use cases where you would want to have this,
	// like when you are packaging your own flatpaks.
	// default: false
	NoDependencies *bool `json:"no_dependencies,omitempty"`

	// The flatpak remote (repository) to install the flatpak from.
	// By default, `flathub` is assumed, but you do need to add the flathub
	// flatpak_remote before you can use this.
	// See the `community.general.flatpak_remote` module for managing flatpak
	// remotes.
	// default: "flathub"
	Remote *string `json:"remote,omitempty"`

	// Indicates the desired package state.
	// The value `latest` is supported since community.general 8.6.0.
	// default: FlatpakStatePresent
	State *FlatpakState `json:"state,omitempty"`
}

// Wrap the `FlatpakParameters into an `rpc.RPCCall`.
func (p *FlatpakParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := rpc.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: FlatpakName,
			Args: args,
		},
	}, nil
}

// Return values for the `flatpak` Ansible module.
type FlatpakReturn struct {
	AnsibleCommonReturns

	// The exact flatpak command that was executed.
	Command *string `json:"command,omitempty"`

	// Module error message.
	Msg *string `json:"msg,omitempty"`

	// Return code from flatpak binary.
	Rc *int `json:"rc,omitempty"`

	// Error output from flatpak binary.
	Stderr *string `json:"stderr,omitempty"`

	// Output from flatpak binary.
	Stdout *string `json:"stdout,omitempty"`
}

// Unwrap the `rpc.RPCResult` into an `FlatpakReturn`
func FlatpakReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (FlatpakReturn, error) {
	return rpc.AnyToJSONT[FlatpakReturn](r.Result.Result)
}
