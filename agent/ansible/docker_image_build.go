// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
	"github.com/sapslaj/mid/pkg/cast"
)

// This module allows you to build Docker images using Docker's buildx plugin
// (BuildKit).
// Note that the module is `not idempotent` in the sense of classical Ansible
// modules. The only idempotence check is whether the built image already
// exists. This check can be disabled with the `rebuild` option.
const DockerImageBuildName = "docker_image_build"

// Defines the behavior of the module if the image to build (as specified in
// `name` and `tag`) already exists.
type DockerImageBuildRebuild string

const (
	DockerImageBuildRebuildNever  DockerImageBuildRebuild = "never"
	DockerImageBuildRebuildAlways DockerImageBuildRebuild = "always"
)

// Convert a supported type to an optional (pointer) DockerImageBuildRebuild
func OptionalDockerImageBuildRebuild[T interface {
	*DockerImageBuildRebuild | DockerImageBuildRebuild | *string | string
}](s T) *DockerImageBuildRebuild {
	switch v := any(s).(type) {
	case *DockerImageBuildRebuild:
		return v
	case DockerImageBuildRebuild:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := DockerImageBuildRebuild(*v)
		return &val
	case string:
		val := DockerImageBuildRebuild(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `docker_image_build` Ansible module.
type DockerImageBuildParameters struct {
	// Image name. Name format will be one of: `name`, `repository/name`,
	// `registry_server:port/name`. When pushing or pulling an image the name can
	// optionally include the tag by appending `:tag_name`.
	// Note that image IDs (hashes) and names with digest cannot be used.
	Name string `json:"name"`

	// Tag for the image name `name` that is to be tagged.
	// If `name`'s format is `name:tag`, then the tag value from `name` will take
	// precedence.
	// default: "latest"
	Tag *string `json:"tag,omitempty"`

	// The path for the build environment.
	Path string `json:"path"`

	// Provide an alternate name for the Dockerfile to use when building an image.
	// This can also include a relative path (relative to `path`).
	Dockerfile *string `json:"dockerfile,omitempty"`

	// List of image names to consider as cache source.
	CacheFrom *[]string `json:"cache_from,omitempty"`

	// When building an image downloads any updates to the FROM image in
	// Dockerfile.
	// default: false
	Pull *bool `json:"pull,omitempty"`

	// The network to use for `RUN` build instructions.
	Network *string `json:"network,omitempty"`

	// Do not use cache when building an image.
	// default: false
	Nocache *bool `json:"nocache,omitempty"`

	// Extra hosts to add to `/etc/hosts` in building containers, as a mapping of
	// hostname to IP address.
	// Instead of an IP address, the special value `host-gateway` can also be used,
	// which resolves to the host's gateway IP and allows building containers to
	// connect to services running on the host.
	EtcHosts *map[string]any `json:"etc_hosts,omitempty"`

	// Provide a dictionary of `key:value` build arguments that map to Dockerfile
	// ARG directive.
	// Docker expects the value to be a string. For convenience any non-string
	// values will be converted to strings.
	Args *map[string]any `json:"args,omitempty"`

	// When building an image specifies an intermediate build stage by name as a
	// final stage for the resulting image.
	Target *string `json:"target,omitempty"`

	// Platforms in the format `os[/arch[/variant]]`.
	// Since community.docker 3.10.0 this can be a list of platforms, instead of
	// just a single platform.
	Platform *[]string `json:"platform,omitempty"`

	// Size of `/dev/shm` in format `<number>[<unit>]`. Number is positive integer.
	// Unit can be `B` (byte), `K` (kibibyte, 1024B), `M` (mebibyte), `G`
	// (gibibyte), `T` (tebibyte), or `P` (pebibyte).
	// Omitting the unit defaults to bytes. If you omit the size entirely, Docker
	// daemon uses `64M`.
	ShmSize *string `json:"shm_size,omitempty"`

	// Dictionary of key value pairs.
	Labels *map[string]any `json:"labels,omitempty"`

	// Defines the behavior of the module if the image to build (as specified in
	// `name` and `tag`) already exists.
	// default: DockerImageBuildRebuildNever
	Rebuild *DockerImageBuildRebuild `json:"rebuild,omitempty"`

	// Secrets to expose to the build.
	Secrets *struct {
		Id    string  `json:"id"`
		Type  string  `json:"type"`
		Src   *string `json:"src,omitempty"`
		Env   *string `json:"env,omitempty"`
		Value *string `json:"value,omitempty"`
	} `json:"secrets,omitempty"`

	// Output destinations.
	// You can provide a list of exporters to export the built image in various
	// places. Note that not all exporters might be supported by the build driver
	// used.
	// Note that depending on how this option is used, no image with name `name`
	// and tag `tag` might be created, which can cause the basic idempotency this
	// module offers to not work.
	// Providing an empty list to this option is equivalent to not specifying it at
	// all. The default behavior is a single entry with `outputs[].type=image`.
	// `Note` that since community.docker 4.2.0, an entry for `name`/`tag` is added
	// if `outputs` has at least one entry and no entry has type
	// `outputs[].type=image` and includes `name`/`tag` in `outputs[].name`. This
	// is because the module would otherwise pass `--tag name:image` to the buildx
	// plugin, which for some reason overwrites all images in `outputs` by the
	// `name:image` provided in `name`/`tag`.
	Outputs *struct {
		Type    string    `json:"type"`
		Dest    *string   `json:"dest,omitempty"`
		Context *string   `json:"context,omitempty"`
		Name    *[]string `json:"name,omitempty"`
		Push    *bool     `json:"push,omitempty"`
	} `json:"outputs,omitempty"`

	// Path to the Docker CLI. If not provided, will search for Docker CLI on the
	// `PATH`.
	DockerCli *string `json:"docker_cli,omitempty"`

	// The URL or Unix socket path used to connect to the Docker API. To connect to
	// a remote host, provide the TCP connection string. For example,
	// `tcp://192.0.2.23:2376`. If TLS is used to encrypt the connection, the
	// module will automatically replace `tcp` in the connection URL with `https`.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_HOST` will be used instead. If the environment variable is not set,
	// the default value will be used.
	// Mutually exclusive with `cli_context`. If neither `docker_host` nor
	// `cli_context` are provided, the value `unix:///var/run/docker.sock` is used.
	DockerHost *string `json:"docker_host,omitempty"`

	// When verifying the authenticity of the Docker Host server, provide the
	// expected name of the server.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TLS_HOSTNAME` will be used instead. If the environment variable is
	// not set, the default value will be used.
	TlsHostname *string `json:"tls_hostname,omitempty"`

	// The version of the Docker API running on the Docker Host.
	// Defaults to the latest version of the API supported by this collection and
	// the docker daemon.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_API_VERSION` will be used instead. If the environment variable is
	// not set, the default value will be used.
	// default: "auto"
	ApiVersion *string `json:"api_version,omitempty"`

	// Use a CA certificate when performing server verification by providing the
	// path to a CA certificate file.
	// If the value is not specified in the task and the environment variable
	// `DOCKER_CERT_PATH` is set, the file `ca.pem` from the directory specified in
	// the environment variable `DOCKER_CERT_PATH` will be used.
	CaPath *string `json:"ca_path,omitempty"`

	// Path to the client's TLS certificate file.
	// If the value is not specified in the task and the environment variable
	// `DOCKER_CERT_PATH` is set, the file `cert.pem` from the directory specified
	// in the environment variable `DOCKER_CERT_PATH` will be used.
	ClientCert *string `json:"client_cert,omitempty"`

	// Path to the client's TLS key file.
	// If the value is not specified in the task and the environment variable
	// `DOCKER_CERT_PATH` is set, the file `key.pem` from the directory specified
	// in the environment variable `DOCKER_CERT_PATH` will be used.
	ClientKey *string `json:"client_key,omitempty"`

	// Secure the connection to the API by using TLS without verifying the
	// authenticity of the Docker host server. Note that if `validate_certs` is set
	// to `true` as well, it will take precedence.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TLS` will be used instead. If the environment variable is not set,
	// the default value will be used.
	// default: false
	Tls *bool `json:"tls,omitempty"`

	// Secure the connection to the API by using TLS and verifying the authenticity
	// of the Docker host server.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TLS_VERIFY` will be used instead. If the environment variable is not
	// set, the default value will be used.
	// default: false
	ValidateCerts *bool `json:"validate_certs,omitempty"`

	// The Docker CLI context to use.
	// Mutually exclusive with `docker_host`.
	CliContext *string `json:"cli_context,omitempty"`
}

// Wrap the `DockerImageBuildParameters into an `rpc.RPCCall`.
func (p DockerImageBuildParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := cast.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: DockerImageBuildName,
			Args: args,
		},
	}, nil
}

// Return values for the `docker_image_build` Ansible module.
type DockerImageBuildReturn struct {
	AnsibleCommonReturns

	// Image inspection results for the affected image.
	Image *map[string]any `json:"image,omitempty"`

	// The command executed.
	Command *[]string `json:"command,omitempty"`
}

// Unwrap the `rpc.RPCResult` into an `DockerImageBuildReturn`
func DockerImageBuildReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (DockerImageBuildReturn, error) {
	return cast.AnyToJSONT[DockerImageBuildReturn](r.Result.Result)
}
