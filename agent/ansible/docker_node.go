// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
	"github.com/sapslaj/mid/pkg/cast"
)

// Manages the Docker nodes through a Swarm Manager.
// This module allows to change the node's role, its availability, and to
// modify, add or remove node labels.
const DockerNodeName = "docker_node"

// It defines the operation on the labels assigned to node and labels specified
// in `labels` option.
// Set to `merge` to combine labels provided in `labels` with those already
// assigned to the node. If no labels are assigned then it will add listed
// labels. For labels that are already assigned to the node, it will update
// their values. The labels not specified in `labels` will remain unchanged. If
// `labels` is empty then no changes will be made.
// Set to `replace` to replace all assigned labels with provided ones. If
// `labels` is empty then all labels assigned to the node will be removed.
type DockerNodeLabelsState string

const (
	DockerNodeLabelsStateMerge   DockerNodeLabelsState = "merge"
	DockerNodeLabelsStateReplace DockerNodeLabelsState = "replace"
)

// Convert a supported type to an optional (pointer) DockerNodeLabelsState
func OptionalDockerNodeLabelsState[T interface {
	*DockerNodeLabelsState | DockerNodeLabelsState | *string | string
}](s T) *DockerNodeLabelsState {
	switch v := any(s).(type) {
	case *DockerNodeLabelsState:
		return v
	case DockerNodeLabelsState:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := DockerNodeLabelsState(*v)
		return &val
	case string:
		val := DockerNodeLabelsState(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Node availability to assign. If not provided then node availability remains
// unchanged.
type DockerNodeAvailability string

const (
	DockerNodeAvailabilityActive DockerNodeAvailability = "active"
	DockerNodeAvailabilityPause  DockerNodeAvailability = "pause"
	DockerNodeAvailabilityDrain  DockerNodeAvailability = "drain"
)

// Convert a supported type to an optional (pointer) DockerNodeAvailability
func OptionalDockerNodeAvailability[T interface {
	*DockerNodeAvailability | DockerNodeAvailability | *string | string
}](s T) *DockerNodeAvailability {
	switch v := any(s).(type) {
	case *DockerNodeAvailability:
		return v
	case DockerNodeAvailability:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := DockerNodeAvailability(*v)
		return &val
	case string:
		val := DockerNodeAvailability(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Node role to assign. If not provided then node role remains unchanged.
type DockerNodeRole string

const (
	DockerNodeRoleManager DockerNodeRole = "manager"
	DockerNodeRoleWorker  DockerNodeRole = "worker"
)

// Convert a supported type to an optional (pointer) DockerNodeRole
func OptionalDockerNodeRole[T interface {
	*DockerNodeRole | DockerNodeRole | *string | string
}](s T) *DockerNodeRole {
	switch v := any(s).(type) {
	case *DockerNodeRole:
		return v
	case DockerNodeRole:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := DockerNodeRole(*v)
		return &val
	case string:
		val := DockerNodeRole(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `docker_node` Ansible module.
type DockerNodeParameters struct {
	// The hostname or ID of node as registered in Swarm.
	// If more than one node is registered using the same hostname the ID must be
	// used, otherwise module will fail.
	Hostname string `json:"hostname"`

	// User-defined key/value metadata that will be assigned as node attribute.
	// Label operations in this module apply to the docker swarm node specified by
	// `hostname`. Use `community.docker.docker_swarm` module to add/modify/remove
	// swarm cluster labels.
	// The actual state of labels assigned to the node when module completes its
	// work depends on `labels_state` and `labels_to_remove` parameters values. See
	// description below.
	Labels *map[string]any `json:"labels,omitempty"`

	// It defines the operation on the labels assigned to node and labels specified
	// in `labels` option.
	// Set to `merge` to combine labels provided in `labels` with those already
	// assigned to the node. If no labels are assigned then it will add listed
	// labels. For labels that are already assigned to the node, it will update
	// their values. The labels not specified in `labels` will remain unchanged. If
	// `labels` is empty then no changes will be made.
	// Set to `replace` to replace all assigned labels with provided ones. If
	// `labels` is empty then all labels assigned to the node will be removed.
	// default: DockerNodeLabelsStateMerge
	LabelsState *DockerNodeLabelsState `json:"labels_state,omitempty"`

	// List of labels that will be removed from the node configuration. The list
	// has to contain only label names, not their values.
	// If the label provided on the list is not assigned to the node, the entry is
	// ignored.
	// If the label is both on the `labels_to_remove` and `labels`, then value
	// provided in `labels` remains assigned to the node.
	// If `labels_state=replace` and `labels` is not provided or empty then all
	// labels assigned to node are removed and `labels_to_remove` is ignored.
	LabelsToRemove *[]string `json:"labels_to_remove,omitempty"`

	// Node availability to assign. If not provided then node availability remains
	// unchanged.
	Availability *DockerNodeAvailability `json:"availability,omitempty"`

	// Node role to assign. If not provided then node role remains unchanged.
	Role *DockerNodeRole `json:"role,omitempty"`

	// The URL or Unix socket path used to connect to the Docker API. To connect to
	// a remote host, provide the TCP connection string. For example,
	// `tcp://192.0.2.23:2376`. If TLS is used to encrypt the connection, the
	// module will automatically replace `tcp` in the connection URL with `https`.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_HOST` will be used instead. If the environment variable is not set,
	// the default value will be used.
	// default: "unix:///var/run/docker.sock"
	DockerHost *string `json:"docker_host,omitempty"`

	// When verifying the authenticity of the Docker Host server, provide the
	// expected name of the server.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TLS_HOSTNAME` will be used instead. If the environment variable is
	// not set, the default value will be used.
	// Note that this option had a default value `localhost` in older versions. It
	// was removed in community.docker 3.0.0.
	// `Note:` this option is no longer supported for Docker SDK for Python 7.0.0+.
	// Specifying it with Docker SDK for Python 7.0.0 or newer will lead to an
	// error.
	TlsHostname *string `json:"tls_hostname,omitempty"`

	// The version of the Docker API running on the Docker Host.
	// Defaults to the latest version of the API supported by Docker SDK for Python
	// and the docker daemon.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_API_VERSION` will be used instead. If the environment variable is
	// not set, the default value will be used.
	// default: "auto"
	ApiVersion *string `json:"api_version,omitempty"`

	// The maximum amount of time in seconds to wait on a response from the API.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TIMEOUT` will be used instead. If the environment variable is not
	// set, the default value will be used.
	// default: 60
	Timeout *int `json:"timeout,omitempty"`

	// Use a CA certificate when performing server verification by providing the
	// path to a CA certificate file.
	// If the value is not specified in the task and the environment variable
	// `DOCKER_CERT_PATH` is set, the file `ca.pem` from the directory specified in
	// the environment variable `DOCKER_CERT_PATH` will be used.
	// This option was called `ca_cert` and got renamed to `ca_path` in
	// community.docker 3.6.0. The old name has been added as an alias and can
	// still be used.
	CaPath *string `json:"ca_path,omitempty"`

	// Path to the client's TLS certificate file.
	// If the value is not specified in the task and the environment variable
	// `DOCKER_CERT_PATH` is set, the file `cert.pem` from the directory specified
	// in the environment variable `DOCKER_CERT_PATH` will be used.
	ClientCert *string `json:"client_cert,omitempty"`

	// Path to the client's TLS key file.
	// If the value is not specified in the task and the environment variable
	// `DOCKER_CERT_PATH` is set, the file `key.pem` from the directory specified
	// in the environment variable `DOCKER_CERT_PATH` will be used.
	ClientKey *string `json:"client_key,omitempty"`

	// Secure the connection to the API by using TLS without verifying the
	// authenticity of the Docker host server. Note that if `validate_certs` is set
	// to `true` as well, it will take precedence.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TLS` will be used instead. If the environment variable is not set,
	// the default value will be used.
	// default: false
	Tls *bool `json:"tls,omitempty"`

	// For SSH transports, use the `ssh` CLI tool instead of paramiko.
	// Requires Docker SDK for Python 4.4.0 or newer.
	// default: false
	UseSshClient *bool `json:"use_ssh_client,omitempty"`

	// Secure the connection to the API by using TLS and verifying the authenticity
	// of the Docker host server.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TLS_VERIFY` will be used instead. If the environment variable is not
	// set, the default value will be used.
	// default: false
	ValidateCerts *bool `json:"validate_certs,omitempty"`

	// Debug mode.
	// default: false
	Debug *bool `json:"debug,omitempty"`
}

// Wrap the `DockerNodeParameters into an `rpc.RPCCall`.
func (p DockerNodeParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := cast.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: DockerNodeName,
			Args: args,
		},
	}, nil
}

// Return values for the `docker_node` Ansible module.
type DockerNodeReturn struct {
	AnsibleCommonReturns

	// Information about node after 'update' operation.
	Node *map[string]any `json:"node,omitempty"`
}

// Unwrap the `rpc.RPCResult` into an `DockerNodeReturn`
func DockerNodeReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (DockerNodeReturn, error) {
	return cast.AnyToJSONT[DockerNodeReturn](r.Result.Result)
}
