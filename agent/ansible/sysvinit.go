// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
	"github.com/sapslaj/mid/pkg/cast"
)

// Controls services on target hosts that use the SysV init system.
const SysvinitName = "sysvinit"

// `started`/`stopped` are idempotent actions that will not run commands unless
// necessary. Not all init scripts support `restarted` nor `reloaded` natively,
// so these will both trigger a stop and start as needed.
type SysvinitState string

const (
	SysvinitStateStarted   SysvinitState = "started"
	SysvinitStateStopped   SysvinitState = "stopped"
	SysvinitStateRestarted SysvinitState = "restarted"
	SysvinitStateReloaded  SysvinitState = "reloaded"
)

// Convert a supported type to an optional (pointer) SysvinitState
func OptionalSysvinitState[T interface {
	*SysvinitState | SysvinitState | *string | string
}](s T) *SysvinitState {
	switch v := any(s).(type) {
	case *SysvinitState:
		return v
	case SysvinitState:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := SysvinitState(*v)
		return &val
	case string:
		val := SysvinitState(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `sysvinit` Ansible module.
type SysvinitParameters struct {
	// Name of the service.
	Name string `json:"name"`

	// `started`/`stopped` are idempotent actions that will not run commands unless
	// necessary. Not all init scripts support `restarted` nor `reloaded` natively,
	// so these will both trigger a stop and start as needed.
	State *SysvinitState `json:"state,omitempty"`

	// Whether the service should start on boot. At least one of `state` and
	// `enabled` are required.
	Enabled *bool `json:"enabled,omitempty"`

	// If the service is being `restarted` or `reloaded` then sleep this many
	// seconds between the stop and start command. This helps to workaround badly
	// behaving services.
	// default: 1
	Sleep *int `json:"sleep,omitempty"`

	// A substring to look for as would be found in the output of the `ps` command
	// as a stand-in for a status result.
	// If the string is found, the service will be assumed to be running.
	// This option is mainly for use with init scripts that don't support the
	// `status` option.
	Pattern *string `json:"pattern,omitempty"`

	// The runlevels this script should be enabled/disabled from.
	// Use this to override the defaults set by the package or init script itself.
	Runlevels *[]string `json:"runlevels,omitempty"`

	// Additional arguments provided on the command line that some init scripts
	// accept.
	Arguments *string `json:"arguments,omitempty"`

	// Have the module daemonize as the service itself might not do so properly.
	// This is useful with badly written init scripts or daemons, which commonly
	// manifests as the task hanging as it is still holding the tty or the service
	// dying when the task is over as the connection closes the session.
	// default: false
	Daemonize *bool `json:"daemonize,omitempty"`
}

// Wrap the `SysvinitParameters into an `rpc.RPCCall`.
func (p SysvinitParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := cast.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: SysvinitName,
			Args: args,
		},
	}, nil
}

// Return values for the `sysvinit` Ansible module.
type SysvinitReturn struct {
	AnsibleCommonReturns

	// results from actions taken
	Results *any `json:"results,omitempty"`
}

// Unwrap the `rpc.RPCResult` into an `SysvinitReturn`
func SysvinitReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (SysvinitReturn, error) {
	return cast.AnyToJSONT[SysvinitReturn](r.Result.Result)
}
