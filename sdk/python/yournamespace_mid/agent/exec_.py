# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload

if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    "ExecResult",
    "AwaitableExecResult",
    "exec_",
    "exec__output",
]


@pulumi.output_type
class ExecResult:
    def __init__(
        __self__,
        command=None,
        dir=None,
        environment=None,
        exit_code=None,
        pid=None,
        stderr=None,
        stdin=None,
        stdout=None,
    ):
        if command and not isinstance(command, list):
            raise TypeError("Expected argument 'command' to be a list")
        pulumi.set(__self__, "command", command)
        if dir and not isinstance(dir, str):
            raise TypeError("Expected argument 'dir' to be a str")
        pulumi.set(__self__, "dir", dir)
        if environment and not isinstance(environment, dict):
            raise TypeError("Expected argument 'environment' to be a dict")
        pulumi.set(__self__, "environment", environment)
        if exit_code and not isinstance(exit_code, int):
            raise TypeError("Expected argument 'exit_code' to be a int")
        pulumi.set(__self__, "exit_code", exit_code)
        if pid and not isinstance(pid, int):
            raise TypeError("Expected argument 'pid' to be a int")
        pulumi.set(__self__, "pid", pid)
        if stderr and not isinstance(stderr, str):
            raise TypeError("Expected argument 'stderr' to be a str")
        pulumi.set(__self__, "stderr", stderr)
        if stdin and not isinstance(stdin, str):
            raise TypeError("Expected argument 'stdin' to be a str")
        pulumi.set(__self__, "stdin", stdin)
        if stdout and not isinstance(stdout, str):
            raise TypeError("Expected argument 'stdout' to be a str")
        pulumi.set(__self__, "stdout", stdout)

    @property
    @pulumi.getter
    def command(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def dir(self) -> Optional[builtins.str]:
        return pulumi.get(self, "dir")

    @property
    @pulumi.getter
    def environment(self) -> Optional[Mapping[str, builtins.str]]:
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="exitCode")
    def exit_code(self) -> builtins.int:
        return pulumi.get(self, "exit_code")

    @property
    @pulumi.getter
    def pid(self) -> builtins.int:
        return pulumi.get(self, "pid")

    @property
    @pulumi.getter
    def stderr(self) -> builtins.str:
        return pulumi.get(self, "stderr")

    @property
    @pulumi.getter
    def stdin(self) -> Optional[builtins.str]:
        return pulumi.get(self, "stdin")

    @property
    @pulumi.getter
    def stdout(self) -> builtins.str:
        return pulumi.get(self, "stdout")


class AwaitableExecResult(ExecResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return ExecResult(
            command=self.command,
            dir=self.dir,
            environment=self.environment,
            exit_code=self.exit_code,
            pid=self.pid,
            stderr=self.stderr,
            stdin=self.stdin,
            stdout=self.stdout,
        )


def exec_(
    command: Optional[Sequence[builtins.str]] = None,
    dir: Optional[builtins.str] = None,
    environment: Optional[Mapping[str, builtins.str]] = None,
    stdin: Optional[builtins.str] = None,
    opts: Optional[pulumi.InvokeOptions] = None,
) -> AwaitableExecResult:
    """
    Use this data source to access information about an existing resource.
    """
    __args__ = dict()
    __args__["command"] = command
    __args__["dir"] = dir
    __args__["environment"] = environment
    __args__["stdin"] = stdin
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke(
        "mid:agent:exec", __args__, opts=opts, typ=ExecResult
    ).value

    return AwaitableExecResult(
        command=pulumi.get(__ret__, "command"),
        dir=pulumi.get(__ret__, "dir"),
        environment=pulumi.get(__ret__, "environment"),
        exit_code=pulumi.get(__ret__, "exit_code"),
        pid=pulumi.get(__ret__, "pid"),
        stderr=pulumi.get(__ret__, "stderr"),
        stdin=pulumi.get(__ret__, "stdin"),
        stdout=pulumi.get(__ret__, "stdout"),
    )


def exec__output(
    command: Optional[pulumi.Input[Sequence[builtins.str]]] = None,
    dir: Optional[pulumi.Input[Optional[builtins.str]]] = None,
    environment: Optional[pulumi.Input[Optional[Mapping[str, builtins.str]]]] = None,
    stdin: Optional[pulumi.Input[Optional[builtins.str]]] = None,
    opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None,
) -> pulumi.Output[ExecResult]:
    """
    Use this data source to access information about an existing resource.
    """
    __args__ = dict()
    __args__["command"] = command
    __args__["dir"] = dir
    __args__["environment"] = environment
    __args__["stdin"] = stdin
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output(
        "mid:agent:exec", __args__, opts=opts, typ=ExecResult
    )
    return __ret__.apply(
        lambda __response__: ExecResult(
            command=pulumi.get(__response__, "command"),
            dir=pulumi.get(__response__, "dir"),
            environment=pulumi.get(__response__, "environment"),
            exit_code=pulumi.get(__response__, "exit_code"),
            pid=pulumi.get(__response__, "pid"),
            stderr=pulumi.get(__response__, "stderr"),
            stdin=pulumi.get(__response__, "stdin"),
            stdout=pulumi.get(__response__, "stdout"),
        )
    )
