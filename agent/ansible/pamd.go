// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
)

// Edit PAM service's type, control, module path and module arguments.
// In order for a PAM rule to be modified, the type, control and module_path
// must match an existing rule. See man(5) pam.d for details.
const PamdName = "pamd"

// The type of the PAM rule being modified.
// The `type`, `control`, and `module_path` options all must match a rule to be
// modified.
type PamdType string

const (
	PamdTypeAccount       PamdType = "account"
	PamdTypeAccountNoLog  PamdType = "-account"
	PamdTypeAuth          PamdType = "auth"
	PamdTypeAuthNoLog     PamdType = "-auth"
	PamdTypePassword      PamdType = "password"
	PamdTypePasswordNoLog PamdType = "-password"
	PamdTypeSession       PamdType = "session"
	PamdTypeSessionNoLog  PamdType = "-session"
)

// The new type to assign to the new rule.
type PamdNewType string

const (
	PamdNewTypeAccount       PamdNewType = "account"
	PamdNewTypeAccountNoLog  PamdNewType = "-account"
	PamdNewTypeAuth          PamdNewType = "auth"
	PamdNewTypeAuthNoLog     PamdNewType = "-auth"
	PamdNewTypePassword      PamdNewType = "password"
	PamdNewTypePasswordNoLog PamdNewType = "-password"
	PamdNewTypeSession       PamdNewType = "session"
	PamdNewTypeSessionNoLog  PamdNewType = "-session"
)

// Convert a supported type to an optional (pointer) PamdNewType
func OptionalPamdNewType[T interface {
	*PamdNewType | PamdNewType | *string | string
}](s T) *PamdNewType {
	switch v := any(s).(type) {
	case *PamdNewType:
		return v
	case PamdNewType:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := PamdNewType(*v)
		return &val
	case string:
		val := PamdNewType(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// The default of `updated` will modify an existing rule if type, control and
// module_path all match an existing rule.
// With `before`, the new rule will be inserted before a rule matching type,
// control and module_path.
// Similarly, with `after`, the new rule will be inserted after an existing
// rulematching type, control and module_path.
// With either `before` or `after` `new_type`, `new_control`, and
// `new_module_path` must all be specified.
// If state is `args_absent` or `args_present`, `new_type`, `new_control`, and
// `new_module_path` will be ignored.
// State `absent` will remove the rule.
type PamdState string

const (
	PamdStateAbsent      PamdState = "absent"
	PamdStateBefore      PamdState = "before"
	PamdStateAfter       PamdState = "after"
	PamdStateArgsAbsent  PamdState = "args_absent"
	PamdStateArgsPresent PamdState = "args_present"
	PamdStateUpdated     PamdState = "updated"
)

// Convert a supported type to an optional (pointer) PamdState
func OptionalPamdState[T interface {
	*PamdState | PamdState | *string | string
}](s T) *PamdState {
	switch v := any(s).(type) {
	case *PamdState:
		return v
	case PamdState:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := PamdState(*v)
		return &val
	case string:
		val := PamdState(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `pamd` Ansible module.
type PamdParameters struct {
	// The name generally refers to the PAM service file to change, for example
	// system-auth.
	Name string `json:"name"`

	// The type of the PAM rule being modified.
	// The `type`, `control`, and `module_path` options all must match a rule to be
	// modified.
	Type PamdType `json:"type"`

	// The control of the PAM rule being modified.
	// This may be a complicated control with brackets. If this is the case, be
	// sure to put "[bracketed controls]" in quotes.
	// The `type`, `control`, and `module_path` options all must match a rule to be
	// modified.
	Control string `json:"control"`

	// The module path of the PAM rule being modified.
	// The `type`, `control`, and `module_path` options all must match a rule to be
	// modified.
	ModulePath string `json:"module_path"`

	// The new type to assign to the new rule.
	NewType *PamdNewType `json:"new_type,omitempty"`

	// The new control to assign to the new rule.
	NewControl *string `json:"new_control,omitempty"`

	// The new module path to be assigned to the new rule.
	NewModulePath *string `json:"new_module_path,omitempty"`

	// When `state=updated`, the `module_arguments` will replace existing
	// module_arguments.
	// When `state=args_absent` args matching those listed in `module_arguments`
	// will be removed.
	// When `state=args_present` any args listed in `module_arguments` are added if
	// missing from the existing rule.
	// Furthermore, if the module argument takes a value denoted by `=`, the value
	// will be changed to that specified in module_arguments.
	ModuleArguments *[]string `json:"module_arguments,omitempty"`

	// The default of `updated` will modify an existing rule if type, control and
	// module_path all match an existing rule.
	// With `before`, the new rule will be inserted before a rule matching type,
	// control and module_path.
	// Similarly, with `after`, the new rule will be inserted after an existing
	// rulematching type, control and module_path.
	// With either `before` or `after` `new_type`, `new_control`, and
	// `new_module_path` must all be specified.
	// If state is `args_absent` or `args_present`, `new_type`, `new_control`, and
	// `new_module_path` will be ignored.
	// State `absent` will remove the rule.
	// default: PamdStateUpdated
	State *PamdState `json:"state,omitempty"`

	// This is the path to the PAM service files.
	// default: "/etc/pam.d"
	Path *string `json:"path,omitempty"`

	// Create a backup file including the timestamp information so you can get the
	// original file back if you somehow clobbered it incorrectly.
	// default: false
	Backup *bool `json:"backup,omitempty"`
}

// Wrap the `PamdParameters into an `rpc.RPCCall`.
func (p PamdParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := rpc.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: PamdName,
			Args: args,
		},
	}, nil
}

// Return values for the `pamd` Ansible module.
type PamdReturn struct {
	AnsibleCommonReturns

	// How many rules were changed.
	ChangeCount *int `json:"change_count,omitempty"`

	// The file name of the backup file, if created.
	Backupdest *string `json:"backupdest,omitempty"`
}

// Unwrap the `rpc.RPCResult` into an `PamdReturn`
func PamdReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (PamdReturn, error) {
	return rpc.AnyToJSONT[PamdReturn](r.Result.Result)
}
