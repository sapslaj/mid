// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
)

// This module is a simple wrapper around `dd` to create, extend or truncate a
// file, given its size. It can be used to manage swap files (that require
// contiguous blocks) or alternatively, huge sparse files.
const FilesizeName = "filesize"

// Parameters for the `filesize` Ansible module.
type FilesizeParameters struct {
	// Path of the regular file to create or resize.
	Path string `json:"path"`

	// Requested size of the file.
	// The value is a number (either `int` or `float`) optionally followed by a
	// multiplicative suffix, that can be one of `B` (bytes), `KB` or `kB` (=
	// 1000B), `MB` or `mB` (= 1000kB), `GB` or `gB` (= 1000MB), and so on for `T`,
	// `P`, `E`, `Z` and `Y`; or alternatively one of `K`, `k` or `KiB` (= 1024B);
	// `M`, `m` or `MiB` (= 1024KiB); `G`, `g` or `GiB` (= 1024MiB); and so on.
	// If the multiplicative suffix is not provided, the value is treated as an
	// integer number of blocks of `blocksize` bytes each (float values are rounded
	// to the closest integer).
	// When the `size` value is equal to the current file size, does nothing.
	// When the `size` value is bigger than the current file size, bytes from
	// `source` (if `sparse` is not `false`) are appended to the file without
	// truncating it, in other words, without modifying the existing bytes of the
	// file.
	// When the `size` value is smaller than the current file size, it is truncated
	// to the requested value without modifying bytes before this value.
	// That means that a file of any arbitrary size can be grown to any other
	// arbitrary size, and then resized down to its initial size without modifying
	// its initial content.
	Size any `json:"size"`

	// Size of blocks, in bytes if not followed by a multiplicative suffix.
	// The numeric value (before the unit) `MUST` be an integer (or a `float` if it
	// equals an integer).
	// If not set, the size of blocks is guessed from the OS and commonly results
	// in `512` or `4096` bytes, that is used internally by the module or when
	// `size` has no unit.
	Blocksize *any `json:"blocksize,omitempty"`

	// Device or file that provides input data to provision the file.
	// This parameter is ignored when `sparse=true`.
	// default: "/dev/zero"
	Source *string `json:"source,omitempty"`

	// Whether or not to overwrite the file if it exists, in other words, to
	// truncate it from 0. When `true`, the module is not idempotent, that means it
	// always reports `changed=true`.
	// `force=true` and `sparse=true` are mutually exclusive.
	// default: false
	Force *bool `json:"force,omitempty"`

	// Whether or not the file to create should be a sparse file.
	// This option is effective only on newly created files, or when growing a
	// file, only for the bytes to append.
	// This option is not supported on OSes or filesystems not supporting sparse
	// files.
	// `force=true` and `sparse=true` are mutually exclusive.
	// default: false
	Sparse *bool `json:"sparse,omitempty"`

	// This option is silently ignored. This module always modifies file size in-
	// place.
	// Influence when to use atomic operation to prevent data corruption or
	// inconsistent reads from the target filesystem object.
	// By default this module uses atomic operations to prevent data corruption or
	// inconsistent reads from the target filesystem objects, but sometimes systems
	// are configured or just broken in ways that prevent this. One example is
	// docker mounted filesystem objects, which cannot be updated atomically from
	// inside the container and can only be written in an unsafe manner.
	// This option allows Ansible to fall back to unsafe methods of updating
	// filesystem objects when atomic operations fail (however, it doesn't force
	// Ansible to perform unsafe writes).
	// IMPORTANT! Unsafe writes are subject to race conditions and can lead to data
	// corruption.
	// default: false
	UnsafeWrites *bool `json:"unsafe_writes,omitempty"`

	// The permissions the resulting filesystem object should have.
	// For those used to `/usr/bin/chmod` remember that modes are actually octal
	// numbers. You must give Ansible enough information to parse them correctly.
	// For consistent results, quote octal numbers (for example, `'644'` or
	// `'1777'`) so Ansible receives a string and can do its own conversion from
	// string into number. Adding a leading zero (for example, `0755`) works
	// sometimes, but can fail in loops and some other circumstances.
	// Giving Ansible a number without following either of these rules will end up
	// with a decimal number which will have unexpected results.
	// As of Ansible 1.8, the mode may be specified as a symbolic mode (for
	// example, `u+rwx` or `u=rw,g=r,o=r`).
	// If `mode` is not specified and the destination filesystem object `does not`
	// exist, the default `umask` on the system will be used when setting the mode
	// for the newly created filesystem object.
	// If `mode` is not specified and the destination filesystem object `does`
	// exist, the mode of the existing filesystem object will be used.
	// Specifying `mode` is the best way to ensure filesystem objects are created
	// with the correct permissions. See CVE-2020-1736 for further details.
	Mode *any `json:"mode,omitempty"`

	// Name of the user that should own the filesystem object, as would be fed to
	// `chown`.
	// When left unspecified, it uses the current user unless you are root, in
	// which case it can preserve the previous ownership.
	// Specifying a numeric username will be assumed to be a user ID and not a
	// username. Avoid numeric usernames to avoid this confusion.
	Owner *string `json:"owner,omitempty"`

	// Name of the group that should own the filesystem object, as would be fed to
	// `chown`.
	// When left unspecified, it uses the current group of the current user unless
	// you are root, in which case it can preserve the previous ownership.
	Group *string `json:"group,omitempty"`

	// The user part of the SELinux filesystem object context.
	// By default it uses the `system` policy, where applicable.
	// When set to `_default`, it will use the `user` portion of the policy if
	// available.
	Seuser *string `json:"seuser,omitempty"`

	// The role part of the SELinux filesystem object context.
	// When set to `_default`, it will use the `role` portion of the policy if
	// available.
	Serole *string `json:"serole,omitempty"`

	// The type part of the SELinux filesystem object context.
	// When set to `_default`, it will use the `type` portion of the policy if
	// available.
	Setype *string `json:"setype,omitempty"`

	// The level part of the SELinux filesystem object context.
	// This is the MLS/MCS attribute, sometimes known as the `range`.
	// When set to `_default`, it will use the `level` portion of the policy if
	// available.
	Selevel *string `json:"selevel,omitempty"`

	// The attributes the resulting filesystem object should have.
	// To get supported flags look at the man page for `chattr` on the target
	// system.
	// This string should contain the attributes in the same order as the one
	// displayed by `lsattr`.
	// The `=` operator is assumed as default, otherwise `+` or `-` operators need
	// to be included in the string.
	Attributes *string `json:"attributes,omitempty"`
}

// Wrap the `FilesizeParameters into an `rpc.RPCCall`.
func (p FilesizeParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := rpc.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: FilesizeName,
			Args: args,
		},
	}, nil
}

// Return values for the `filesize` Ansible module.
type FilesizeReturn struct {
	AnsibleCommonReturns

	// Command executed to create or resize the file.
	Cmd *string `json:"cmd,omitempty"`

	// Dictionary of sizes related to the file.
	Filesize *map[string]any `json:"filesize,omitempty"`

	// Difference (positive or negative) between old size and new size, in bytes.
	SizeDiff *int `json:"size_diff,omitempty"`

	// Realpath of the file if it is a symlink, otherwise the same than module's
	// param.
	Path *string `json:"path,omitempty"`
}

// Unwrap the `rpc.RPCResult` into an `FilesizeReturn`
func FilesizeReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (FilesizeReturn, error) {
	return rpc.AnyToJSONT[FilesizeReturn](r.Result.Result)
}
