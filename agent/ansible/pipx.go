// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
	"github.com/sapslaj/mid/pkg/cast"
)

// Manage Python applications installed in isolated virtualenvs using pipx.
const PipxName = "pipx"

// Desired state for the application.
// The states `present` and `absent` are aliases to `install` and `uninstall`,
// respectively.
// The state `latest` is equivalent to executing the task twice, with state
// `install` and then `upgrade`. It was added in community.general 5.5.0.
// The states `install_all`, `uninject`, `upgrade_shared`, `pin` and `unpin` are
// only available in `pipx>=1.6.0`, make sure to have a compatible version when
// using this option. These states have been added in community.general 9.4.0.
type PipxState string

const (
	PipxStatePresent       PipxState = "present"
	PipxStateAbsent        PipxState = "absent"
	PipxStateInstall       PipxState = "install"
	PipxStateInstallAll    PipxState = "install_all"
	PipxStateUninstall     PipxState = "uninstall"
	PipxStateUninstallAll  PipxState = "uninstall_all"
	PipxStateInject        PipxState = "inject"
	PipxStateUninject      PipxState = "uninject"
	PipxStateUpgrade       PipxState = "upgrade"
	PipxStateUpgradeShared PipxState = "upgrade_shared"
	PipxStateUpgradeAll    PipxState = "upgrade_all"
	PipxStateReinstall     PipxState = "reinstall"
	PipxStateReinstallAll  PipxState = "reinstall_all"
	PipxStateLatest        PipxState = "latest"
	PipxStatePin           PipxState = "pin"
	PipxStateUnpin         PipxState = "unpin"
)

// Convert a supported type to an optional (pointer) PipxState
func OptionalPipxState[T interface {
	*PipxState | PipxState | *string | string
}](s T) *PipxState {
	switch v := any(s).(type) {
	case *PipxState:
		return v
	case PipxState:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := PipxState(*v)
		return &val
	case string:
		val := PipxState(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `pipx` Ansible module.
type PipxParameters struct {
	// Desired state for the application.
	// The states `present` and `absent` are aliases to `install` and `uninstall`,
	// respectively.
	// The state `latest` is equivalent to executing the task twice, with state
	// `install` and then `upgrade`. It was added in community.general 5.5.0.
	// The states `install_all`, `uninject`, `upgrade_shared`, `pin` and `unpin`
	// are only available in `pipx>=1.6.0`, make sure to have a compatible version
	// when using this option. These states have been added in community.general
	// 9.4.0.
	// default: PipxStateInstall
	State *PipxState `json:"state,omitempty"`

	// The name of the application and also the name of the Python package being
	// installed.
	// In `pipx` documentation it is also referred to as the name of the virtual
	// environment where the application is installed.
	// If `name` is a simple package name without version specifiers, then that
	// name is used as the Python package name to be installed.
	// Starting in community.general 10.7.0, you can use package specifiers when
	// `state=present` or `state=install`. For example, `name=tox<4.0.0` or
	// `name=tox>3.0.27`.
	// Please note that when you use `state=present` and `name` with version
	// specifiers, contrary to the behavior of `pipx`, this module honors the
	// version specifier and installs a version of the application that satisfies
	// it. If you want to ensure the reinstallation of the application even when
	// the version specifier is met, then you must use `force=true`, or perhaps use
	// `state=upgrade` instead.
	// Use `source` for installing from URLs or directories.
	Name *string `json:"name,omitempty"`

	// Source for the package. This option is used when `state=install` or
	// `state=latest`, and it is ignored with other states.
	// Use `source` when installing a Python package with version specifier, or
	// from a local path, from a VCS URL or compressed file.
	// The value of this option is passed as-is to `pipx`.
	// `name` is still required when using `source` to establish the application
	// name without fetching the package from a remote source.
	// The module is not idempotent when using `source`.
	Source *string `json:"source,omitempty"`

	// Add apps from the injected packages.
	// Only used when `state=inject`.
	// default: false
	InstallApps *bool `json:"install_apps,omitempty"`

	// Include applications of dependent packages.
	// Only used when `state=install`, `state=latest`, or `state=inject`.
	// default: false
	InstallDeps *bool `json:"install_deps,omitempty"`

	// Packages to be injected into an existing virtual environment.
	// Only used when `state=inject`.
	InjectPackages *[]string `json:"inject_packages,omitempty"`

	// Force modification of the application's virtual environment. See `pipx` for
	// details.
	// Only used when `state=install`, `state=upgrade`, `state=upgrade_all`,
	// `state=latest`, or `state=inject`.
	// The module is not idempotent when `force=true`.
	// default: false
	Force *bool `json:"force,omitempty"`

	// Upgrade the injected packages along with the application.
	// Only used when `state=upgrade`, `state=upgrade_all`, or `state=latest`.
	// This is used with `state=upgrade` and `state=latest` since community.general
	// 6.6.0.
	// default: false
	IncludeInjected *bool `json:"include_injected,omitempty"`

	// Base URL of Python Package Index.
	// Only used when `state=install`, `state=upgrade`, `state=latest`, or
	// `state=inject`.
	IndexUrl *string `json:"index_url,omitempty"`

	// Python version to be used when creating the application virtual environment.
	// Must be 3.6+.
	// Only used when `state=install`, `state=latest`, `state=reinstall`, or
	// `state=reinstall_all`.
	Python *string `json:"python,omitempty"`

	// Give application virtual environment access to the system site-packages
	// directory.
	// Only used when `state=install` or `state=latest`.
	// default: false
	SystemSitePackages *bool `json:"system_site_packages,omitempty"`

	// Install the project in editable mode.
	// default: false
	Editable *bool `json:"editable,omitempty"`

	// Arbitrary arguments to pass directly to `pip`.
	PipArgs *string `json:"pip_args,omitempty"`

	// Optional suffix for virtual environment and executable names.
	// `Warning:` `pipx` documentation states this is an `experimental` feature
	// subject to change.
	Suffix *string `json:"suffix,omitempty"`

	// The module will pass the `--global` argument to `pipx`, to execute actions
	// in global scope.
	// The `--global` is only available in `pipx>=1.6.0`, so make sure to have a
	// compatible version when using this option. Moreover, a nasty bug with
	// `--global` was fixed in `pipx==1.7.0`, so it is strongly recommended you
	// used that version or newer.
	// default: false
	Global *bool `json:"global,omitempty"`

	// Spec metadata file for `state=install_all`.
	// This content of the file is usually generated with `pipx list --json`, and
	// it can be obtained with `community.general.pipx_info` with
	// `community.general.pipx_info#module:include_raw=true` and obtaining the
	// content from the R`community.general.pipx_info#module:raw_output`.
	SpecMetadata *string `json:"spec_metadata,omitempty"`

	// Path to the `pipx` installed in the system.
	// If not specified, the module will use `python -m pipx` to run the tool,
	// using the same Python interpreter as ansible itself.
	Executable *string `json:"executable,omitempty"`
}

// Wrap the `PipxParameters into an `rpc.RPCCall`.
func (p PipxParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := cast.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: PipxName,
			Args: args,
		},
	}, nil
}

// Return values for the `pipx` Ansible module.
type PipxReturn struct {
	AnsibleCommonReturns

	// Version of pipx.
	Version *string `json:"version,omitempty"`
}

// Unwrap the `rpc.RPCResult` into an `PipxReturn`
func PipxReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (PipxReturn, error) {
	return cast.AnyToJSONT[PipxReturn](r.Result.Result)
}
