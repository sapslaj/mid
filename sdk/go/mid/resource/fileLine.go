// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package resource

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/sapslaj/mid/sdk/go/mid/internal"
	"github.com/sapslaj/mid/sdk/go/mid/types"
)

type FileLine struct {
	pulumi.CustomResourceState

	_drifted     pulumi.StringArrayOutput   `pulumi:"_drifted"`
	Backrefs     pulumi.BoolPtrOutput       `pulumi:"backrefs"`
	Backup       pulumi.BoolPtrOutput       `pulumi:"backup"`
	Create       pulumi.BoolPtrOutput       `pulumi:"create"`
	Ensure       pulumi.StringPtrOutput     `pulumi:"ensure"`
	FirstMatch   pulumi.BoolPtrOutput       `pulumi:"firstMatch"`
	InsertAfter  pulumi.StringPtrOutput     `pulumi:"insertAfter"`
	InsertBefore pulumi.StringPtrOutput     `pulumi:"insertBefore"`
	Line         pulumi.StringPtrOutput     `pulumi:"line"`
	Path         pulumi.StringOutput        `pulumi:"path"`
	Regexp       pulumi.StringPtrOutput     `pulumi:"regexp"`
	SearchString pulumi.StringPtrOutput     `pulumi:"searchString"`
	Triggers     types.TriggersOutputOutput `pulumi:"triggers"`
	UnsafeWrites pulumi.BoolPtrOutput       `pulumi:"unsafeWrites"`
	Validate     pulumi.StringPtrOutput     `pulumi:"validate"`
}

// NewFileLine registers a new resource with the given unique name, arguments, and options.
func NewFileLine(ctx *pulumi.Context,
	name string, args *FileLineArgs, opts ...pulumi.ResourceOption) (*FileLine, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Path == nil {
		return nil, errors.New("invalid value for required argument 'Path'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource FileLine
	err := ctx.RegisterResource("mid:resource:FileLine", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFileLine gets an existing FileLine resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFileLine(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FileLineState, opts ...pulumi.ResourceOption) (*FileLine, error) {
	var resource FileLine
	err := ctx.ReadResource("mid:resource:FileLine", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering FileLine resources.
type fileLineState struct {
}

type FileLineState struct {
}

func (FileLineState) ElementType() reflect.Type {
	return reflect.TypeOf((*fileLineState)(nil)).Elem()
}

type fileLineArgs struct {
	Backrefs     *bool                `pulumi:"backrefs"`
	Backup       *bool                `pulumi:"backup"`
	Create       *bool                `pulumi:"create"`
	Ensure       *string              `pulumi:"ensure"`
	FirstMatch   *bool                `pulumi:"firstMatch"`
	InsertAfter  *string              `pulumi:"insertAfter"`
	InsertBefore *string              `pulumi:"insertBefore"`
	Line         *string              `pulumi:"line"`
	Path         string               `pulumi:"path"`
	Regexp       *string              `pulumi:"regexp"`
	SearchString *string              `pulumi:"searchString"`
	Triggers     *types.TriggersInput `pulumi:"triggers"`
	UnsafeWrites *bool                `pulumi:"unsafeWrites"`
	Validate     *string              `pulumi:"validate"`
}

// The set of arguments for constructing a FileLine resource.
type FileLineArgs struct {
	Backrefs     pulumi.BoolPtrInput
	Backup       pulumi.BoolPtrInput
	Create       pulumi.BoolPtrInput
	Ensure       pulumi.StringPtrInput
	FirstMatch   pulumi.BoolPtrInput
	InsertAfter  pulumi.StringPtrInput
	InsertBefore pulumi.StringPtrInput
	Line         pulumi.StringPtrInput
	Path         pulumi.StringInput
	Regexp       pulumi.StringPtrInput
	SearchString pulumi.StringPtrInput
	Triggers     types.TriggersInputPtrInput
	UnsafeWrites pulumi.BoolPtrInput
	Validate     pulumi.StringPtrInput
}

func (FileLineArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*fileLineArgs)(nil)).Elem()
}

type FileLineInput interface {
	pulumi.Input

	ToFileLineOutput() FileLineOutput
	ToFileLineOutputWithContext(ctx context.Context) FileLineOutput
}

func (*FileLine) ElementType() reflect.Type {
	return reflect.TypeOf((**FileLine)(nil)).Elem()
}

func (i *FileLine) ToFileLineOutput() FileLineOutput {
	return i.ToFileLineOutputWithContext(context.Background())
}

func (i *FileLine) ToFileLineOutputWithContext(ctx context.Context) FileLineOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileLineOutput)
}

// FileLineArrayInput is an input type that accepts FileLineArray and FileLineArrayOutput values.
// You can construct a concrete instance of `FileLineArrayInput` via:
//
//	FileLineArray{ FileLineArgs{...} }
type FileLineArrayInput interface {
	pulumi.Input

	ToFileLineArrayOutput() FileLineArrayOutput
	ToFileLineArrayOutputWithContext(context.Context) FileLineArrayOutput
}

type FileLineArray []FileLineInput

func (FileLineArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FileLine)(nil)).Elem()
}

func (i FileLineArray) ToFileLineArrayOutput() FileLineArrayOutput {
	return i.ToFileLineArrayOutputWithContext(context.Background())
}

func (i FileLineArray) ToFileLineArrayOutputWithContext(ctx context.Context) FileLineArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileLineArrayOutput)
}

// FileLineMapInput is an input type that accepts FileLineMap and FileLineMapOutput values.
// You can construct a concrete instance of `FileLineMapInput` via:
//
//	FileLineMap{ "key": FileLineArgs{...} }
type FileLineMapInput interface {
	pulumi.Input

	ToFileLineMapOutput() FileLineMapOutput
	ToFileLineMapOutputWithContext(context.Context) FileLineMapOutput
}

type FileLineMap map[string]FileLineInput

func (FileLineMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FileLine)(nil)).Elem()
}

func (i FileLineMap) ToFileLineMapOutput() FileLineMapOutput {
	return i.ToFileLineMapOutputWithContext(context.Background())
}

func (i FileLineMap) ToFileLineMapOutputWithContext(ctx context.Context) FileLineMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileLineMapOutput)
}

type FileLineOutput struct{ *pulumi.OutputState }

func (FileLineOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FileLine)(nil)).Elem()
}

func (o FileLineOutput) ToFileLineOutput() FileLineOutput {
	return o
}

func (o FileLineOutput) ToFileLineOutputWithContext(ctx context.Context) FileLineOutput {
	return o
}

func (o FileLineOutput) _drifted() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FileLine) pulumi.StringArrayOutput { return v._drifted }).(pulumi.StringArrayOutput)
}

func (o FileLineOutput) Backrefs() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FileLine) pulumi.BoolPtrOutput { return v.Backrefs }).(pulumi.BoolPtrOutput)
}

func (o FileLineOutput) Backup() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FileLine) pulumi.BoolPtrOutput { return v.Backup }).(pulumi.BoolPtrOutput)
}

func (o FileLineOutput) Create() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FileLine) pulumi.BoolPtrOutput { return v.Create }).(pulumi.BoolPtrOutput)
}

func (o FileLineOutput) Ensure() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileLine) pulumi.StringPtrOutput { return v.Ensure }).(pulumi.StringPtrOutput)
}

func (o FileLineOutput) FirstMatch() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FileLine) pulumi.BoolPtrOutput { return v.FirstMatch }).(pulumi.BoolPtrOutput)
}

func (o FileLineOutput) InsertAfter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileLine) pulumi.StringPtrOutput { return v.InsertAfter }).(pulumi.StringPtrOutput)
}

func (o FileLineOutput) InsertBefore() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileLine) pulumi.StringPtrOutput { return v.InsertBefore }).(pulumi.StringPtrOutput)
}

func (o FileLineOutput) Line() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileLine) pulumi.StringPtrOutput { return v.Line }).(pulumi.StringPtrOutput)
}

func (o FileLineOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v *FileLine) pulumi.StringOutput { return v.Path }).(pulumi.StringOutput)
}

func (o FileLineOutput) Regexp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileLine) pulumi.StringPtrOutput { return v.Regexp }).(pulumi.StringPtrOutput)
}

func (o FileLineOutput) SearchString() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileLine) pulumi.StringPtrOutput { return v.SearchString }).(pulumi.StringPtrOutput)
}

func (o FileLineOutput) Triggers() types.TriggersOutputOutput {
	return o.ApplyT(func(v *FileLine) types.TriggersOutputOutput { return v.Triggers }).(types.TriggersOutputOutput)
}

func (o FileLineOutput) UnsafeWrites() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FileLine) pulumi.BoolPtrOutput { return v.UnsafeWrites }).(pulumi.BoolPtrOutput)
}

func (o FileLineOutput) Validate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileLine) pulumi.StringPtrOutput { return v.Validate }).(pulumi.StringPtrOutput)
}

type FileLineArrayOutput struct{ *pulumi.OutputState }

func (FileLineArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FileLine)(nil)).Elem()
}

func (o FileLineArrayOutput) ToFileLineArrayOutput() FileLineArrayOutput {
	return o
}

func (o FileLineArrayOutput) ToFileLineArrayOutputWithContext(ctx context.Context) FileLineArrayOutput {
	return o
}

func (o FileLineArrayOutput) Index(i pulumi.IntInput) FileLineOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *FileLine {
		return vs[0].([]*FileLine)[vs[1].(int)]
	}).(FileLineOutput)
}

type FileLineMapOutput struct{ *pulumi.OutputState }

func (FileLineMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FileLine)(nil)).Elem()
}

func (o FileLineMapOutput) ToFileLineMapOutput() FileLineMapOutput {
	return o
}

func (o FileLineMapOutput) ToFileLineMapOutputWithContext(ctx context.Context) FileLineMapOutput {
	return o
}

func (o FileLineMapOutput) MapIndex(k pulumi.StringInput) FileLineOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *FileLine {
		return vs[0].(map[string]*FileLine)[vs[1].(string)]
	}).(FileLineOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FileLineInput)(nil)).Elem(), &FileLine{})
	pulumi.RegisterInputType(reflect.TypeOf((*FileLineArrayInput)(nil)).Elem(), FileLineArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FileLineMapInput)(nil)).Elem(), FileLineMap{})
	pulumi.RegisterOutputType(FileLineOutput{})
	pulumi.RegisterOutputType(FileLineArrayOutput{})
	pulumi.RegisterOutputType(FileLineMapOutput{})
}
