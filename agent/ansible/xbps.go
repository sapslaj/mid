// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
)

// Manage packages with the XBPS package manager.
const XbpsName = "xbps"

// Desired state of the package.
type XbpsState string

const (
	XbpsStatePresent   XbpsState = "present"
	XbpsStateAbsent    XbpsState = "absent"
	XbpsStateLatest    XbpsState = "latest"
	XbpsStateInstalled XbpsState = "installed"
	XbpsStateRemoved   XbpsState = "removed"
)

// Convert a supported type to an optional (pointer) XbpsState
func OptionalXbpsState[T interface {
	*XbpsState | XbpsState | *string | string
}](s T) *XbpsState {
	switch v := any(s).(type) {
	case *XbpsState:
		return v
	case XbpsState:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := XbpsState(*v)
		return &val
	case string:
		val := XbpsState(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `xbps` Ansible module.
type XbpsParameters struct {
	// Name of the package to install, upgrade, or remove.
	Name *[]string `json:"name,omitempty"`

	// Desired state of the package.
	// default: XbpsStatePresent
	State *XbpsState `json:"state,omitempty"`

	// When removing a package, also remove its dependencies, provided that they
	// are not required by other packages and were not explicitly installed by a
	// user.
	// default: false
	Recurse *bool `json:"recurse,omitempty"`

	// Whether or not to refresh the master package lists. This can be run as part
	// of a package installation or as a separate step.
	// default: true
	UpdateCache *bool `json:"update_cache,omitempty"`

	// Whether or not to upgrade whole system.
	// default: false
	Upgrade *bool `json:"upgrade,omitempty"`

	// Whether or not to upgrade the `xbps` package when necessary. Before
	// installing new packages, `xbps` requires the user to update itself. Thus
	// when this option is set to `false`, upgrades and installations fail when
	// `xbps` is not up to date.
	// default: true
	UpgradeXbps *bool `json:"upgrade_xbps,omitempty"`

	// The full path for the target root directory.
	Root *string `json:"root,omitempty"`

	// Repository UR`s` to prepend to the repository list for the package
	// installation. The URL can be remote repositories or paths for local
	// repositories.
	Repositories *[]string `json:"repositories,omitempty"`

	// Whether or not repository signing keys should be automatically accepted.
	// default: false
	AcceptPubkey *bool `json:"accept_pubkey,omitempty"`
}

// Wrap the `XbpsParameters into an `rpc.RPCCall`.
func (p XbpsParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := rpc.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: XbpsName,
			Args: args,
		},
	}, nil
}

// Return values for the `xbps` Ansible module.
type XbpsReturn struct {
	AnsibleCommonReturns

	// Message about results.
	Msg *string `json:"msg,omitempty"`

	// Packages that are affected/would be affected.
	Packages *[]any `json:"packages,omitempty"`
}

// Unwrap the `rpc.RPCResult` into an `XbpsReturn`
func XbpsReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (XbpsReturn, error) {
	return rpc.AnyToJSONT[XbpsReturn](r.Result.Result)
}
