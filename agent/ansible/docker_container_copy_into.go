// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
	"github.com/sapslaj/mid/pkg/cast"
)

// Copy a file into a Docker container.
// Similar to `docker cp`.
// To copy files in a non-running container, you must provide the `owner_id` and
// `group_id` options. This is also necessary if the container does not contain
// a `/bin/sh` shell with an `id` tool.
const DockerContainerCopyIntoName = "docker_container_copy_into"

// Determines how to parse the `mode` parameter.
type DockerContainerCopyIntoModeParse string

const (
	// Parses the value of `mode` as an integer.
	// Note that if you provide an octal number as a string to `mode`, it will be
	// parsed as a `decimal` number. If you provide an octal integer directly,
	// though, it will work as expected.
	// This has been the default behavior of the module since it was added to
	// community.docker.
	DockerContainerCopyIntoModeParseLegacy DockerContainerCopyIntoModeParse = "legacy"
	// Parses the value of `mode` as an octal string, or takes the integer value if
	// an integer has been provided.
	// This is how `ansible.builtin.copy` treats its
	// `ansible.builtin.copy#module:mode` option.
	DockerContainerCopyIntoModeParseModern DockerContainerCopyIntoModeParse = "modern"
	// Rejects everything that is not a string that can be parsed as an octal
	// number.
	// Use this value to ensure that no accidental conversion to integers happen.
	DockerContainerCopyIntoModeParseOctalStringOnly DockerContainerCopyIntoModeParse = "octal_string_only"
)

// Convert a supported type to an optional (pointer) DockerContainerCopyIntoModeParse
func OptionalDockerContainerCopyIntoModeParse[T interface {
	*DockerContainerCopyIntoModeParse | DockerContainerCopyIntoModeParse | *string | string
}](s T) *DockerContainerCopyIntoModeParse {
	switch v := any(s).(type) {
	case *DockerContainerCopyIntoModeParse:
		return v
	case DockerContainerCopyIntoModeParse:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := DockerContainerCopyIntoModeParse(*v)
		return &val
	case string:
		val := DockerContainerCopyIntoModeParse(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `docker_container_copy_into` Ansible module.
type DockerContainerCopyIntoParameters struct {
	// The name of the container to copy files to.
	Container string `json:"container"`

	// Path to a file on the managed node.
	// Mutually exclusive with `content`. One of `content` and `path` is required.
	Path *string `json:"path,omitempty"`

	// The file's content.
	// If you plan to provide binary data, provide it pre-encoded to base64, and
	// set `content_is_b64=true`.
	// Mutually exclusive with `path`. One of `content` and `path` is required.
	Content *string `json:"content,omitempty"`

	// If set to `true`, the content in `content` is assumed to be Base64 encoded
	// and will be decoded before being used.
	// To use binary `content`, it is better to keep it Base64 encoded and let it
	// be decoded by this option. Otherwise you risk the data to be interpreted as
	// UTF-8 and corrupted.
	// default: false
	ContentIsB64 *bool `json:"content_is_b64,omitempty"`

	// Path to a file inside the Docker container.
	// Must be an absolute path.
	ContainerPath string `json:"container_path"`

	// This flag indicates that filesystem links in the Docker container, if they
	// exist, should be followed.
	// default: false
	Follow *bool `json:"follow,omitempty"`

	// This flag indicates that filesystem links in the source tree (where the
	// module is executed), if they exist, should be followed.
	// default: true
	LocalFollow *bool `json:"local_follow,omitempty"`

	// The owner ID to use when writing the file to disk.
	// If provided, `group_id` must also be provided.
	// If not provided, the module will try to determine the user and group ID for
	// the current user in the container. This will only work if `/bin/sh` is
	// present in the container and the `id` binary or shell builtin is available.
	// Also the container must be running.
	OwnerId *int `json:"owner_id,omitempty"`

	// The group ID to use when writing the file to disk.
	// If provided, `owner_id` must also be provided.
	// If not provided, the module will try to determine the user and group ID for
	// the current user in the container. This will only work if `/bin/sh` is
	// present in the container and the `id` binary or shell builtin is available.
	// Also the container must be running.
	GroupId *int `json:"group_id,omitempty"`

	// The file mode to use when writing the file to disk.
	// Will use the file's mode from the source system if this option is not
	// provided.
	// This option is parsed depending on how `mode_parse` is set.
	Mode *any `json:"mode,omitempty"`

	// Determines how to parse the `mode` parameter.
	// default: DockerContainerCopyIntoModeParseLegacy
	ModeParse *DockerContainerCopyIntoModeParse `json:"mode_parse,omitempty"`

	// If set to `true`, force writing the file (without performing any idempotency
	// checks).
	// If set to `false`, only write the file if it does not exist on the target.
	// If a filesystem object exists at the destination, the module will not do any
	// change.
	// If this option is not specified, the module will be idempotent. To verify
	// idempotency, it will try to get information on the filesystem object in the
	// container, and if everything seems to match will download the file from the
	// container to compare it to the file to upload.
	Force *bool `json:"force,omitempty"`

	// The URL or Unix socket path used to connect to the Docker API. To connect to
	// a remote host, provide the TCP connection string. For example,
	// `tcp://192.0.2.23:2376`. If TLS is used to encrypt the connection, the
	// module will automatically replace `tcp` in the connection URL with `https`.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_HOST` will be used instead. If the environment variable is not set,
	// the default value will be used.
	// default: "unix:///var/run/docker.sock"
	DockerHost *string `json:"docker_host,omitempty"`

	// When verifying the authenticity of the Docker Host server, provide the
	// expected name of the server.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TLS_HOSTNAME` will be used instead. If the environment variable is
	// not set, the default value will be used.
	// Note that this option had a default value `localhost` in older versions. It
	// was removed in community.docker 3.0.0.
	TlsHostname *string `json:"tls_hostname,omitempty"`

	// The version of the Docker API running on the Docker Host.
	// Defaults to the latest version of the API supported by this collection and
	// the docker daemon.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_API_VERSION` will be used instead. If the environment variable is
	// not set, the default value will be used.
	// default: "auto"
	ApiVersion *string `json:"api_version,omitempty"`

	// The maximum amount of time in seconds to wait on a response from the API.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TIMEOUT` will be used instead. If the environment variable is not
	// set, the default value will be used.
	// default: 60
	Timeout *int `json:"timeout,omitempty"`

	// Use a CA certificate when performing server verification by providing the
	// path to a CA certificate file.
	// If the value is not specified in the task and the environment variable
	// `DOCKER_CERT_PATH` is set, the file `ca.pem` from the directory specified in
	// the environment variable `DOCKER_CERT_PATH` will be used.
	// This option was called `ca_cert` and got renamed to `ca_path` in
	// community.docker 3.6.0. The old name has been added as an alias and can
	// still be used.
	CaPath *string `json:"ca_path,omitempty"`

	// Path to the client's TLS certificate file.
	// If the value is not specified in the task and the environment variable
	// `DOCKER_CERT_PATH` is set, the file `cert.pem` from the directory specified
	// in the environment variable `DOCKER_CERT_PATH` will be used.
	ClientCert *string `json:"client_cert,omitempty"`

	// Path to the client's TLS key file.
	// If the value is not specified in the task and the environment variable
	// `DOCKER_CERT_PATH` is set, the file `key.pem` from the directory specified
	// in the environment variable `DOCKER_CERT_PATH` will be used.
	ClientKey *string `json:"client_key,omitempty"`

	// Secure the connection to the API by using TLS without verifying the
	// authenticity of the Docker host server. Note that if `validate_certs` is set
	// to `true` as well, it will take precedence.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TLS` will be used instead. If the environment variable is not set,
	// the default value will be used.
	// default: false
	Tls *bool `json:"tls,omitempty"`

	// For SSH transports, use the `ssh` CLI tool instead of paramiko.
	// default: false
	UseSshClient *bool `json:"use_ssh_client,omitempty"`

	// Secure the connection to the API by using TLS and verifying the authenticity
	// of the Docker host server.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TLS_VERIFY` will be used instead. If the environment variable is not
	// set, the default value will be used.
	// default: false
	ValidateCerts *bool `json:"validate_certs,omitempty"`

	// Debug mode
	// default: false
	Debug *bool `json:"debug,omitempty"`
}

// Wrap the `DockerContainerCopyIntoParameters into an `rpc.RPCCall`.
func (p DockerContainerCopyIntoParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := cast.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: DockerContainerCopyIntoName,
			Args: args,
		},
	}, nil
}

// Return values for the `docker_container_copy_into` Ansible module.
type DockerContainerCopyIntoReturn struct {
	AnsibleCommonReturns

	// The actual path in the container.
	// Can only be different from `container_path` when `follow=true`.
	ContainerPath *string `json:"container_path,omitempty"`
}

// Unwrap the `rpc.RPCResult` into an `DockerContainerCopyIntoReturn`
func DockerContainerCopyIntoReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (DockerContainerCopyIntoReturn, error) {
	return cast.AnyToJSONT[DockerContainerCopyIntoReturn](r.Result.Result)
}
