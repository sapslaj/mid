// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
	"github.com/sapslaj/mid/pkg/cast"
)

// Build, load or pull an image, making the image available for creating
// containers. Also supports tagging an image, pushing an image, and archiving
// an image to a `.tar` file.
// We recommend to use the individual modules
// `community.docker.docker_image_build`,
// `community.docker.docker_image_export`, `community.docker.docker_image_load`,
// `community.docker.docker_image_pull`, `community.docker.docker_image_push`,
// `community.docker.docker_image_remove`, and
// `community.docker.docker_image_tag` instead of this module.
const DockerImageName = "docker_image"

// Determines where the module will try to retrieve the image from.
// Use `build` to build the image from a `Dockerfile`. `build.path` must be
// specified when this value is used.
// Use `load` to load the image from a `.tar` file. `load_path` must be
// specified when this value is used.
// Use `pull` to pull the image from a registry.
// Use `local` to make sure that the image is already available on the local
// docker daemon. This means that the module does not try to build, pull or load
// the image.
type DockerImageSource string

const (
	DockerImageSourceBuild DockerImageSource = "build"
	DockerImageSourceLoad  DockerImageSource = "load"
	DockerImageSourcePull  DockerImageSource = "pull"
	DockerImageSourceLocal DockerImageSource = "local"
)

// Convert a supported type to an optional (pointer) DockerImageSource
func OptionalDockerImageSource[T interface {
	*DockerImageSource | DockerImageSource | *string | string
}](s T) *DockerImageSource {
	switch v := any(s).(type) {
	case *DockerImageSource:
		return v
	case DockerImageSource:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := DockerImageSource(*v)
		return &val
	case string:
		val := DockerImageSource(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Make assertions about the state of an image.
// When `absent` an image will be removed. Use the force option to un-tag and
// remove all images matching the provided name.
// When `present` check if an image exists using the provided name and tag. If
// the image is not found or the force option is used, the image will either be
// pulled, built or loaded, depending on the `source` option.
type DockerImageState string

const (
	DockerImageStateAbsent  DockerImageState = "absent"
	DockerImageStatePresent DockerImageState = "present"
)

// Convert a supported type to an optional (pointer) DockerImageState
func OptionalDockerImageState[T interface {
	*DockerImageState | DockerImageState | *string | string
}](s T) *DockerImageState {
	switch v := any(s).(type) {
	case *DockerImageState:
		return v
	case DockerImageState:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := DockerImageState(*v)
		return &val
	case string:
		val := DockerImageState(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `docker_image` Ansible module.
type DockerImageParameters struct {
	// Determines where the module will try to retrieve the image from.
	// Use `build` to build the image from a `Dockerfile`. `build.path` must be
	// specified when this value is used.
	// Use `load` to load the image from a `.tar` file. `load_path` must be
	// specified when this value is used.
	// Use `pull` to pull the image from a registry.
	// Use `local` to make sure that the image is already available on the local
	// docker daemon. This means that the module does not try to build, pull or
	// load the image.
	Source *DockerImageSource `json:"source,omitempty"`

	// Specifies options used for building images.
	Build *struct {
		CacheFrom       *[]string       `json:"cache_from,omitempty"`
		Dockerfile      *string         `json:"dockerfile,omitempty"`
		HttpTimeout     *int            `json:"http_timeout,omitempty"`
		Path            string          `json:"path"`
		Pull            *bool           `json:"pull,omitempty"`
		Rm              *bool           `json:"rm,omitempty"`
		Network         *string         `json:"network,omitempty"`
		Nocache         *bool           `json:"nocache,omitempty"`
		EtcHosts        *map[string]any `json:"etc_hosts,omitempty"`
		Args            *map[string]any `json:"args,omitempty"`
		ContainerLimits *struct {
			Memory     *string `json:"memory,omitempty"`
			Memswap    *string `json:"memswap,omitempty"`
			Cpushares  *int    `json:"cpushares,omitempty"`
			Cpusetcpus *string `json:"cpusetcpus,omitempty"`
		} `json:"container_limits,omitempty"`
		UseConfigProxy *bool           `json:"use_config_proxy,omitempty"`
		Target         *string         `json:"target,omitempty"`
		Platform       *string         `json:"platform,omitempty"`
		ShmSize        *string         `json:"shm_size,omitempty"`
		Labels         *map[string]any `json:"labels,omitempty"`
	} `json:"build,omitempty"`

	// Use with `state=present` to archive an image to a `.tar` file.
	ArchivePath *string `json:"archive_path,omitempty"`

	// Use with `state=present` to load an image from a `.tar` file.
	// Set `source=load` if you want to load the image.
	LoadPath *string `json:"load_path,omitempty"`

	// Use with `state=present` to build, load or pull an image (depending on the
	// value of the `source` option) when the image already exists.
	// default: false
	ForceSource *bool `json:"force_source,omitempty"`

	// Use with `state=absent` to un-tag and remove all images matching the
	// specified name.
	// default: false
	ForceAbsent *bool `json:"force_absent,omitempty"`

	// Use with `state=present` to force tagging an image.
	// default: false
	ForceTag *bool `json:"force_tag,omitempty"`

	// Image name. Name format will be one of: `name`, `repository/name`,
	// `registry_server:port/name`. When pushing or pulling an image the name can
	// optionally include the tag by appending `:tag_name`.
	// Note that image IDs (hashes) are only supported for `state=absent`, for
	// `state=present` with `source=load`, and for `state=present` with
	// `source=local`.
	Name string `json:"name"`

	// Specifies options used for pulling images.
	Pull *struct {
		Platform *string `json:"platform,omitempty"`
	} `json:"pull,omitempty"`

	// Push the image to the registry. Specify the registry as part of the `name`
	// or `repository` parameter.
	// default: false
	Push *bool `json:"push,omitempty"`

	// Use with `state=present` to tag the image.
	// Expects format `repository:tag`. If no tag is provided, will use the value
	// of the `tag` parameter or `latest`.
	// If `push=true`, `repository` must either include a registry, or will be
	// assumed to belong to the default registry (Docker Hub).
	Repository *string `json:"repository,omitempty"`

	// Make assertions about the state of an image.
	// When `absent` an image will be removed. Use the force option to un-tag and
	// remove all images matching the provided name.
	// When `present` check if an image exists using the provided name and tag. If
	// the image is not found or the force option is used, the image will either be
	// pulled, built or loaded, depending on the `source` option.
	// default: DockerImageStatePresent
	State *DockerImageState `json:"state,omitempty"`

	// Used to select an image when pulling. Will be added to the image when
	// pushing, tagging or building. Defaults to `latest`.
	// If `name` parameter format is `name:tag`, then tag value from `name` will
	// take precedence.
	// default: "latest"
	Tag *string `json:"tag,omitempty"`

	// The URL or Unix socket path used to connect to the Docker API. To connect to
	// a remote host, provide the TCP connection string. For example,
	// `tcp://192.0.2.23:2376`. If TLS is used to encrypt the connection, the
	// module will automatically replace `tcp` in the connection URL with `https`.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_HOST` will be used instead. If the environment variable is not set,
	// the default value will be used.
	// default: "unix:///var/run/docker.sock"
	DockerHost *string `json:"docker_host,omitempty"`

	// When verifying the authenticity of the Docker Host server, provide the
	// expected name of the server.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TLS_HOSTNAME` will be used instead. If the environment variable is
	// not set, the default value will be used.
	// Note that this option had a default value `localhost` in older versions. It
	// was removed in community.docker 3.0.0.
	TlsHostname *string `json:"tls_hostname,omitempty"`

	// The version of the Docker API running on the Docker Host.
	// Defaults to the latest version of the API supported by this collection and
	// the docker daemon.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_API_VERSION` will be used instead. If the environment variable is
	// not set, the default value will be used.
	// default: "auto"
	ApiVersion *string `json:"api_version,omitempty"`

	// The maximum amount of time in seconds to wait on a response from the API.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TIMEOUT` will be used instead. If the environment variable is not
	// set, the default value will be used.
	// default: 60
	Timeout *int `json:"timeout,omitempty"`

	// Use a CA certificate when performing server verification by providing the
	// path to a CA certificate file.
	// If the value is not specified in the task and the environment variable
	// `DOCKER_CERT_PATH` is set, the file `ca.pem` from the directory specified in
	// the environment variable `DOCKER_CERT_PATH` will be used.
	// This option was called `ca_cert` and got renamed to `ca_path` in
	// community.docker 3.6.0. The old name has been added as an alias and can
	// still be used.
	CaPath *string `json:"ca_path,omitempty"`

	// Path to the client's TLS certificate file.
	// If the value is not specified in the task and the environment variable
	// `DOCKER_CERT_PATH` is set, the file `cert.pem` from the directory specified
	// in the environment variable `DOCKER_CERT_PATH` will be used.
	ClientCert *string `json:"client_cert,omitempty"`

	// Path to the client's TLS key file.
	// If the value is not specified in the task and the environment variable
	// `DOCKER_CERT_PATH` is set, the file `key.pem` from the directory specified
	// in the environment variable `DOCKER_CERT_PATH` will be used.
	ClientKey *string `json:"client_key,omitempty"`

	// Secure the connection to the API by using TLS without verifying the
	// authenticity of the Docker host server. Note that if `validate_certs` is set
	// to `true` as well, it will take precedence.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TLS` will be used instead. If the environment variable is not set,
	// the default value will be used.
	// default: false
	Tls *bool `json:"tls,omitempty"`

	// For SSH transports, use the `ssh` CLI tool instead of paramiko.
	// default: false
	UseSshClient *bool `json:"use_ssh_client,omitempty"`

	// Secure the connection to the API by using TLS and verifying the authenticity
	// of the Docker host server.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TLS_VERIFY` will be used instead. If the environment variable is not
	// set, the default value will be used.
	// default: false
	ValidateCerts *bool `json:"validate_certs,omitempty"`

	// Debug mode
	// default: false
	Debug *bool `json:"debug,omitempty"`
}

// Wrap the `DockerImageParameters into an `rpc.RPCCall`.
func (p DockerImageParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := cast.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: DockerImageName,
			Args: args,
		},
	}, nil
}

// Return values for the `docker_image` Ansible module.
type DockerImageReturn struct {
	AnsibleCommonReturns

	// Image inspection results for the affected image.
	Image *map[string]any `json:"image,omitempty"`

	// Docker build output when building an image.
	Stdout *string `json:"stdout,omitempty"`
}

// Unwrap the `rpc.RPCResult` into an `DockerImageReturn`
func DockerImageReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (DockerImageReturn, error) {
	return cast.AnyToJSONT[DockerImageReturn](r.Result.Result)
}
