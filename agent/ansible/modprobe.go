// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
)

// Load or unload kernel modules.
const ModprobeName = "modprobe"

// Whether the module should be present or absent.
type ModprobeState string

const (
	ModprobeStateAbsent  ModprobeState = "absent"
	ModprobeStatePresent ModprobeState = "present"
)

func OptionalModprobeState[T interface {
	*ModprobeState | ModprobeState | *string | string
}](s T) *ModprobeState {
	switch v := any(s).(type) {
	case *ModprobeState:
		return v
	case ModprobeState:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := ModprobeState(*v)
		return &val
	case string:
		val := ModprobeState(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Persistency between reboots for configured module.
// This option creates files in `/etc/modules-load.d/` and `/etc/modprobe.d/`
// that make your module configuration persistent during reboots.
// If `present`, adds module name to `/etc/modules-load.d/` and params to
// `/etc/modprobe.d/` so the module will be loaded on next reboot.
// If `absent`, will comment out module name from `/etc/modules-load.d/` and
// comment out params from `/etc/modprobe.d/` so the module will not be loaded
// on next reboot.
// If `disabled`, will not touch anything and leave `/etc/modules-load.d/` and
// `/etc/modprobe.d/` as it is.
// Note that it is usually a better idea to rely on the automatic module loading
// by PCI IDs, USB IDs, DMI IDs or similar triggers encoded in the kernel
// modules themselves instead of configuration like this.
// In fact, most modern kernel modules are prepared for automatic loading
// already.
// `Note:` This option works only with distributions that use `systemd` when set
// to values other than `disabled`.
type ModprobePersistent string

const (
	ModprobePersistentDisabled ModprobePersistent = "disabled"
	ModprobePersistentAbsent   ModprobePersistent = "absent"
	ModprobePersistentPresent  ModprobePersistent = "present"
)

func OptionalModprobePersistent[T interface {
	*ModprobePersistent | ModprobePersistent | *string | string
}](s T) *ModprobePersistent {
	switch v := any(s).(type) {
	case *ModprobePersistent:
		return v
	case ModprobePersistent:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := ModprobePersistent(*v)
		return &val
	case string:
		val := ModprobePersistent(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `modprobe` Ansible module.
type ModprobeParameters struct {
	// Name of kernel module to manage.
	Name string `json:"name"`

	// Whether the module should be present or absent.
	// default: ModprobeStatePresent
	State *ModprobeState `json:"state,omitempty"`

	// Modules parameters.
	// default: ""
	Params *string `json:"params,omitempty"`

	// Persistency between reboots for configured module.
	// This option creates files in `/etc/modules-load.d/` and `/etc/modprobe.d/`
	// that make your module configuration persistent during reboots.
	// If `present`, adds module name to `/etc/modules-load.d/` and params to
	// `/etc/modprobe.d/` so the module will be loaded on next reboot.
	// If `absent`, will comment out module name from `/etc/modules-load.d/` and
	// comment out params from `/etc/modprobe.d/` so the module will not be loaded
	// on next reboot.
	// If `disabled`, will not touch anything and leave `/etc/modules-load.d/` and
	// `/etc/modprobe.d/` as it is.
	// Note that it is usually a better idea to rely on the automatic module
	// loading by PCI IDs, USB IDs, DMI IDs or similar triggers encoded in the
	// kernel modules themselves instead of configuration like this.
	// In fact, most modern kernel modules are prepared for automatic loading
	// already.
	// `Note:` This option works only with distributions that use `systemd` when
	// set to values other than `disabled`.
	// default: ModprobePersistentDisabled
	Persistent *ModprobePersistent `json:"persistent,omitempty"`
}

// Wrap the `ModprobeParameters into an `rpc.RPCCall`.
func (p *ModprobeParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := rpc.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: ModprobeName,
			Args: args,
		},
	}, nil
}

// Return values for the `modprobe` Ansible module.
type ModprobeReturn struct {
	AnsibleCommonReturns
}

// Unwrap the `rpc.RPCResult` into an `ModprobeReturn`
func ModprobeReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (ModprobeReturn, error) {
	return rpc.AnyToJSONT[ModprobeReturn](r.Result.Result)
}
