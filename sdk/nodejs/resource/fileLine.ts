// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

export class FileLine extends pulumi.CustomResource {
  /**
   * Get an existing FileLine resource's state with the given name, ID, and optional extra
   * properties used to qualify the lookup.
   *
   * @param name The _unique_ name of the resulting resource.
   * @param id The _unique_ provider ID of the resource to lookup.
   * @param opts Optional settings to control the behavior of the CustomResource.
   */
  public static get(name: string, id: pulumi.Input<pulumi.ID>, opts?: pulumi.CustomResourceOptions): FileLine {
    return new FileLine(name, undefined as any, { ...opts, id: id });
  }

  /** @internal */
  public static readonly __pulumiType = "mid:resource:FileLine";

  /**
   * Returns true if the given object is an instance of FileLine.  This is designed to work even
   * when multiple copies of the Pulumi SDK have been loaded into the same process.
   */
  public static isInstance(obj: any): obj is FileLine {
    if (obj === undefined || obj === null) {
      return false;
    }
    return obj["__pulumiType"] === FileLine.__pulumiType;
  }

  public readonly /*out*/ _drifted!: pulumi.Output<string[]>;
  public readonly backrefs!: pulumi.Output<boolean | undefined>;
  public readonly backup!: pulumi.Output<boolean | undefined>;
  public readonly config!: pulumi.Output<outputs.ResourceConfig | undefined>;
  public readonly connection!: pulumi.Output<outputs.Connection | undefined>;
  public readonly create!: pulumi.Output<boolean | undefined>;
  public readonly ensure!: pulumi.Output<string | undefined>;
  public readonly firstMatch!: pulumi.Output<boolean | undefined>;
  public readonly insertAfter!: pulumi.Output<string | undefined>;
  public readonly insertBefore!: pulumi.Output<string | undefined>;
  public readonly line!: pulumi.Output<string | undefined>;
  public readonly path!: pulumi.Output<string>;
  public readonly regexp!: pulumi.Output<string | undefined>;
  public readonly searchString!: pulumi.Output<string | undefined>;
  public readonly triggers!: pulumi.Output<outputs.TriggersOutput>;
  public readonly unsafeWrites!: pulumi.Output<boolean | undefined>;
  public readonly validate!: pulumi.Output<string | undefined>;

  /**
   * Create a FileLine resource with the given unique name, arguments, and options.
   *
   * @param name The _unique_ name of the resource.
   * @param args The arguments to use to populate this resource's properties.
   * @param opts A bag of options that control this resource's behavior.
   */
  constructor(name: string, args: FileLineArgs, opts?: pulumi.CustomResourceOptions) {
    let resourceInputs: pulumi.Inputs = {};
    opts = opts || {};
    if (!opts.id) {
      if (args?.path === undefined && !opts.urn) {
        throw new Error("Missing required property 'path'");
      }
      resourceInputs["backrefs"] = args?.backrefs;
      resourceInputs["backup"] = args?.backup;
      resourceInputs["config"] = args?.config;
      resourceInputs["connection"] = args
        ? (args.connection ? pulumi.output(args.connection).apply(inputs.connectionArgsProvideDefaults) : undefined)
        : undefined;
      resourceInputs["create"] = args?.create;
      resourceInputs["ensure"] = args?.ensure;
      resourceInputs["firstMatch"] = args?.firstMatch;
      resourceInputs["insertAfter"] = args?.insertAfter;
      resourceInputs["insertBefore"] = args?.insertBefore;
      resourceInputs["line"] = args?.line;
      resourceInputs["path"] = args?.path;
      resourceInputs["regexp"] = args?.regexp;
      resourceInputs["searchString"] = args?.searchString;
      resourceInputs["triggers"] = args?.triggers;
      resourceInputs["unsafeWrites"] = args?.unsafeWrites;
      resourceInputs["validate"] = args?.validate;
      resourceInputs["_drifted"] = undefined /*out*/;
    } else {
      resourceInputs["_drifted"] = undefined /*out*/;
      resourceInputs["backrefs"] = undefined /*out*/;
      resourceInputs["backup"] = undefined /*out*/;
      resourceInputs["config"] = undefined /*out*/;
      resourceInputs["connection"] = undefined /*out*/;
      resourceInputs["create"] = undefined /*out*/;
      resourceInputs["ensure"] = undefined /*out*/;
      resourceInputs["firstMatch"] = undefined /*out*/;
      resourceInputs["insertAfter"] = undefined /*out*/;
      resourceInputs["insertBefore"] = undefined /*out*/;
      resourceInputs["line"] = undefined /*out*/;
      resourceInputs["path"] = undefined /*out*/;
      resourceInputs["regexp"] = undefined /*out*/;
      resourceInputs["searchString"] = undefined /*out*/;
      resourceInputs["triggers"] = undefined /*out*/;
      resourceInputs["unsafeWrites"] = undefined /*out*/;
      resourceInputs["validate"] = undefined /*out*/;
    }
    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
    super(FileLine.__pulumiType, name, resourceInputs, opts);
  }
}

/**
 * The set of arguments for constructing a FileLine resource.
 */
export interface FileLineArgs {
  backrefs?: pulumi.Input<boolean>;
  backup?: pulumi.Input<boolean>;
  config?: pulumi.Input<inputs.ResourceConfigArgs>;
  connection?: pulumi.Input<inputs.ConnectionArgs>;
  create?: pulumi.Input<boolean>;
  ensure?: pulumi.Input<string>;
  firstMatch?: pulumi.Input<boolean>;
  insertAfter?: pulumi.Input<string>;
  insertBefore?: pulumi.Input<string>;
  line?: pulumi.Input<string>;
  path: pulumi.Input<string>;
  regexp?: pulumi.Input<string>;
  searchString?: pulumi.Input<string>;
  triggers?: pulumi.Input<inputs.TriggersInputArgs>;
  unsafeWrites?: pulumi.Input<boolean>;
  validate?: pulumi.Input<string>;
}
