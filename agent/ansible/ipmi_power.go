// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
	"github.com/sapslaj/mid/pkg/cast"
)

// Use this module for power management.
const IpmiPowerName = "ipmi_power"

// Whether to ensure that the machine in desired state.
// The choices for state are:
// `on` -- Request system turn on.
// `off` -- Request system turn off without waiting for OS to shutdown.
// `shutdown` -- Have system request OS proper shutdown.
// `reset` -- Request system reset without waiting for OS.
// `boot` -- If system is off, then `on`, else `reset`.
// Either this option or `machine` is required.
type IpmiPowerState string

const (
	IpmiPowerStateOn       IpmiPowerState = "on"
	IpmiPowerStateOff      IpmiPowerState = "off"
	IpmiPowerStateShutdown IpmiPowerState = "shutdown"
	IpmiPowerStateReset    IpmiPowerState = "reset"
	IpmiPowerStateBoot     IpmiPowerState = "boot"
)

// Convert a supported type to an optional (pointer) IpmiPowerState
func OptionalIpmiPowerState[T interface {
	*IpmiPowerState | IpmiPowerState | *string | string
}](s T) *IpmiPowerState {
	switch v := any(s).(type) {
	case *IpmiPowerState:
		return v
	case IpmiPowerState:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := IpmiPowerState(*v)
		return &val
	case string:
		val := IpmiPowerState(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `ipmi_power` Ansible module.
type IpmiPowerParameters struct {
	// Hostname or IP address of the BMC.
	Name string `json:"name"`

	// Remote RMCP port.
	// default: 623
	Port *int `json:"port,omitempty"`

	// Username to use to connect to the BMC.
	User string `json:"user"`

	// Password to connect to the BMC.
	Password string `json:"password"`

	// Encryption key to connect to the BMC in hex format.
	Key *string `json:"key,omitempty"`

	// Whether to ensure that the machine in desired state.
	// The choices for state are:
	// `on` -- Request system turn on.
	// `off` -- Request system turn off without waiting for OS to shutdown.
	// `shutdown` -- Have system request OS proper shutdown.
	// `reset` -- Request system reset without waiting for OS.
	// `boot` -- If system is off, then `on`, else `reset`.
	// Either this option or `machine` is required.
	State *IpmiPowerState `json:"state,omitempty"`

	// Maximum number of seconds before interrupt request.
	// default: 300
	Timeout *int `json:"timeout,omitempty"`

	// Provide a list of the remote target address for the bridge IPMI request, and
	// the power status.
	// Either this option or `state` is required.
	Machine *struct {
		Targetaddress int     `json:"targetAddress"`
		State         *string `json:"state,omitempty"`
	} `json:"machine,omitempty"`
}

// Wrap the `IpmiPowerParameters into an `rpc.RPCCall`.
func (p IpmiPowerParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := cast.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: IpmiPowerName,
			Args: args,
		},
	}, nil
}

// Return values for the `ipmi_power` Ansible module.
type IpmiPowerReturn struct {
	AnsibleCommonReturns

	// The current power state of the machine.
	Powerstate *string `json:"powerstate,omitempty"`

	// The current power state of the machine when the machine option is set.
	Status *map[string]any `json:"status,omitempty"`
}

// Unwrap the `rpc.RPCResult` into an `IpmiPowerReturn`
func IpmiPowerReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (IpmiPowerReturn, error) {
	return cast.AnyToJSONT[IpmiPowerReturn](r.Result.Result)
}
