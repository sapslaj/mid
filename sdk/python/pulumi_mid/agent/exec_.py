# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload

if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from .. import _inputs as _root_inputs
from .. import outputs as _root_outputs

__all__ = [
    "ExecResult",
    "AwaitableExecResult",
    "exec_",
    "exec__output",
]


@pulumi.output_type
class ExecResult:
    def __init__(
        __self__,
        command=None,
        config=None,
        connection=None,
        dir=None,
        environment=None,
        exit_code=None,
        expand_argument_vars=None,
        pid=None,
        stderr=None,
        stdin=None,
        stdout=None,
    ):
        if command and not isinstance(command, list):
            raise TypeError("Expected argument 'command' to be a list")
        pulumi.set(__self__, "command", command)
        if config and not isinstance(config, dict):
            raise TypeError("Expected argument 'config' to be a dict")
        pulumi.set(__self__, "config", config)
        if connection and not isinstance(connection, dict):
            raise TypeError("Expected argument 'connection' to be a dict")
        pulumi.set(__self__, "connection", connection)
        if dir and not isinstance(dir, str):
            raise TypeError("Expected argument 'dir' to be a str")
        pulumi.set(__self__, "dir", dir)
        if environment and not isinstance(environment, dict):
            raise TypeError("Expected argument 'environment' to be a dict")
        pulumi.set(__self__, "environment", environment)
        if exit_code and not isinstance(exit_code, int):
            raise TypeError("Expected argument 'exit_code' to be a int")
        pulumi.set(__self__, "exit_code", exit_code)
        if expand_argument_vars and not isinstance(expand_argument_vars, bool):
            raise TypeError("Expected argument 'expand_argument_vars' to be a bool")
        pulumi.set(__self__, "expand_argument_vars", expand_argument_vars)
        if pid and not isinstance(pid, int):
            raise TypeError("Expected argument 'pid' to be a int")
        pulumi.set(__self__, "pid", pid)
        if stderr and not isinstance(stderr, str):
            raise TypeError("Expected argument 'stderr' to be a str")
        pulumi.set(__self__, "stderr", stderr)
        if stdin and not isinstance(stdin, str):
            raise TypeError("Expected argument 'stdin' to be a str")
        pulumi.set(__self__, "stdin", stdin)
        if stdout and not isinstance(stdout, str):
            raise TypeError("Expected argument 'stdout' to be a str")
        pulumi.set(__self__, "stdout", stdout)

    @_builtins.property
    @pulumi.getter
    def command(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "command")

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional["_root_outputs.ResourceConfig"]:
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional["_root_outputs.Connection"]:
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter
    def dir(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dir")

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "environment")

    @_builtins.property
    @pulumi.getter(name="exitCode")
    def exit_code(self) -> _builtins.int:
        return pulumi.get(self, "exit_code")

    @_builtins.property
    @pulumi.getter(name="expandArgumentVars")
    def expand_argument_vars(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "expand_argument_vars")

    @_builtins.property
    @pulumi.getter
    def pid(self) -> _builtins.int:
        return pulumi.get(self, "pid")

    @_builtins.property
    @pulumi.getter
    def stderr(self) -> _builtins.str:
        return pulumi.get(self, "stderr")

    @_builtins.property
    @pulumi.getter
    def stdin(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "stdin")

    @_builtins.property
    @pulumi.getter
    def stdout(self) -> _builtins.str:
        return pulumi.get(self, "stdout")


class AwaitableExecResult(ExecResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return ExecResult(
            command=self.command,
            config=self.config,
            connection=self.connection,
            dir=self.dir,
            environment=self.environment,
            exit_code=self.exit_code,
            expand_argument_vars=self.expand_argument_vars,
            pid=self.pid,
            stderr=self.stderr,
            stdin=self.stdin,
            stdout=self.stdout,
        )


def exec_(
    command: Optional[Sequence[_builtins.str]] = None,
    config: Optional[
        Union["_root_inputs.ResourceConfig", "_root_inputs.ResourceConfigDict"]
    ] = None,
    connection: Optional[
        Union["_root_inputs.Connection", "_root_inputs.ConnectionDict"]
    ] = None,
    dir: Optional[_builtins.str] = None,
    environment: Optional[Mapping[str, _builtins.str]] = None,
    expand_argument_vars: Optional[_builtins.bool] = None,
    stdin: Optional[_builtins.str] = None,
    opts: Optional[pulumi.InvokeOptions] = None,
) -> AwaitableExecResult:
    """
    Use this data source to access information about an existing resource.
    """
    __args__ = dict()
    __args__["command"] = command
    __args__["config"] = config
    __args__["connection"] = connection
    __args__["dir"] = dir
    __args__["environment"] = environment
    __args__["expandArgumentVars"] = expand_argument_vars
    __args__["stdin"] = stdin
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke(
        "mid:agent:exec", __args__, opts=opts, typ=ExecResult
    ).value

    return AwaitableExecResult(
        command=pulumi.get(__ret__, "command"),
        config=pulumi.get(__ret__, "config"),
        connection=pulumi.get(__ret__, "connection"),
        dir=pulumi.get(__ret__, "dir"),
        environment=pulumi.get(__ret__, "environment"),
        exit_code=pulumi.get(__ret__, "exit_code"),
        expand_argument_vars=pulumi.get(__ret__, "expand_argument_vars"),
        pid=pulumi.get(__ret__, "pid"),
        stderr=pulumi.get(__ret__, "stderr"),
        stdin=pulumi.get(__ret__, "stdin"),
        stdout=pulumi.get(__ret__, "stdout"),
    )


def exec__output(
    command: Optional[pulumi.Input[Sequence[_builtins.str]]] = None,
    config: Optional[
        pulumi.Input[
            Optional[
                Union["_root_inputs.ResourceConfig", "_root_inputs.ResourceConfigDict"]
            ]
        ]
    ] = None,
    connection: Optional[
        pulumi.Input[
            Optional[Union["_root_inputs.Connection", "_root_inputs.ConnectionDict"]]
        ]
    ] = None,
    dir: Optional[pulumi.Input[Optional[_builtins.str]]] = None,
    environment: Optional[pulumi.Input[Optional[Mapping[str, _builtins.str]]]] = None,
    expand_argument_vars: Optional[pulumi.Input[Optional[_builtins.bool]]] = None,
    stdin: Optional[pulumi.Input[Optional[_builtins.str]]] = None,
    opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None,
) -> pulumi.Output[ExecResult]:
    """
    Use this data source to access information about an existing resource.
    """
    __args__ = dict()
    __args__["command"] = command
    __args__["config"] = config
    __args__["connection"] = connection
    __args__["dir"] = dir
    __args__["environment"] = environment
    __args__["expandArgumentVars"] = expand_argument_vars
    __args__["stdin"] = stdin
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output(
        "mid:agent:exec", __args__, opts=opts, typ=ExecResult
    )
    return __ret__.apply(
        lambda __response__: ExecResult(
            command=pulumi.get(__response__, "command"),
            config=pulumi.get(__response__, "config"),
            connection=pulumi.get(__response__, "connection"),
            dir=pulumi.get(__response__, "dir"),
            environment=pulumi.get(__response__, "environment"),
            exit_code=pulumi.get(__response__, "exit_code"),
            expand_argument_vars=pulumi.get(__response__, "expand_argument_vars"),
            pid=pulumi.get(__response__, "pid"),
            stderr=pulumi.get(__response__, "stderr"),
            stdin=pulumi.get(__response__, "stdin"),
            stdout=pulumi.get(__response__, "stdout"),
        )
    )
