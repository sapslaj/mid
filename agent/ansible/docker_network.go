// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
	"github.com/sapslaj/mid/pkg/cast"
)

// Create/remove Docker networks and connect containers to them.
// Performs largely the same function as the `docker network` CLI subcommand.
const DockerNetworkName = "docker_network"

// `absent` deletes the network. If a network has connected containers, these
// will be detached from the network.
// `present` creates the network, if it does not already exist with the
// specified parameters, and connects the list of containers provided by the
// `connected` parameter. Containers not on the list will be disconnected. An
// empty list will leave no containers connected to the network. Use the
// `appends` option to leave existing containers connected. Use the `force`
// options to force re-creation of the network.
type DockerNetworkState string

const (
	DockerNetworkStateAbsent  DockerNetworkState = "absent"
	DockerNetworkStatePresent DockerNetworkState = "present"
)

// Convert a supported type to an optional (pointer) DockerNetworkState
func OptionalDockerNetworkState[T interface {
	*DockerNetworkState | DockerNetworkState | *string | string
}](s T) *DockerNetworkState {
	switch v := any(s).(type) {
	case *DockerNetworkState:
		return v
	case DockerNetworkState:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := DockerNetworkState(*v)
		return &val
	case string:
		val := DockerNetworkState(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Specify the network's scope.
type DockerNetworkScope string

const (
	DockerNetworkScopeLocal  DockerNetworkScope = "local"
	DockerNetworkScopeGlobal DockerNetworkScope = "global"
	DockerNetworkScopeSwarm  DockerNetworkScope = "swarm"
)

// Convert a supported type to an optional (pointer) DockerNetworkScope
func OptionalDockerNetworkScope[T interface {
	*DockerNetworkScope | DockerNetworkScope | *string | string
}](s T) *DockerNetworkScope {
	switch v := any(s).(type) {
	case *DockerNetworkScope:
		return v
	case DockerNetworkScope:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := DockerNetworkScope(*v)
		return &val
	case string:
		val := DockerNetworkScope(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `docker_network` Ansible module.
type DockerNetworkParameters struct {
	// Name of the network to operate on.
	Name string `json:"name"`

	// Specifies the config only network to use the config from.
	ConfigFrom *string `json:"config_from,omitempty"`

	// Sets that this is a config only network.
	ConfigOnly *bool `json:"config_only,omitempty"`

	// List of container names or container IDs to connect to a network.
	// Please note that the module only makes sure that these containers are
	// connected to the network, but does not care about connection options. If you
	// rely on specific IP addresses and so on, use the
	// `community.docker.docker_container` module to ensure your containers are
	// correctly connected to this network.
	// default: []
	Connected *[]string `json:"connected,omitempty"`

	// Specify the type of network. Docker provides bridge and overlay drivers, but
	// 3rd party drivers can also be used.
	// default: "bridge"
	Driver *string `json:"driver,omitempty"`

	// Dictionary of network settings. Consult docker docs for valid options and
	// values.
	// default: {}
	DriverOptions *map[string]any `json:"driver_options,omitempty"`

	// With state `present` will disconnect all containers for existing networks,
	// delete the network and re-create the network.
	// This option is required if you have changed the IPAM or driver options and
	// want an existing network to be updated to use the new options.
	// default: false
	Force *bool `json:"force,omitempty"`

	// By default the connected list is canonical, meaning containers not on the
	// list are removed from the network.
	// Use `appends` to leave existing containers connected.
	// default: false
	Appends *bool `json:"appends,omitempty"`

	// Enable IPv4 networking.
	// This is enabled by default, but can be explicitly disabled.
	// Requires Docker API 1.47 or newer.
	EnableIpv4 *bool `json:"enable_ipv4,omitempty"`

	// Enable IPv6 networking.
	EnableIpv6 *bool `json:"enable_ipv6,omitempty"`

	// Enable Swarm routing-mesh.
	Ingress *bool `json:"ingress,omitempty"`

	// Specify an IPAM driver.
	IpamDriver *string `json:"ipam_driver,omitempty"`

	// Dictionary of IPAM driver options.
	IpamDriverOptions *map[string]any `json:"ipam_driver_options,omitempty"`

	// List of IPAM config blocks. Consult `Docker
	// docs,https://docs.docker.com/compose/compose-file/compose-file-v2/#ipam` for
	// valid options and values. Note that `ipam_config[].iprange` is spelled
	// differently here (we use the notation from the Docker SDK for Python).
	IpamConfig *struct {
		Subnet       *string         `json:"subnet,omitempty"`
		Iprange      *string         `json:"iprange,omitempty"`
		Gateway      *string         `json:"gateway,omitempty"`
		AuxAddresses *map[string]any `json:"aux_addresses,omitempty"`
	} `json:"ipam_config,omitempty"`

	// `absent` deletes the network. If a network has connected containers, these
	// will be detached from the network.
	// `present` creates the network, if it does not already exist with the
	// specified parameters, and connects the list of containers provided by the
	// `connected` parameter. Containers not on the list will be disconnected. An
	// empty list will leave no containers connected to the network. Use the
	// `appends` option to leave existing containers connected. Use the `force`
	// options to force re-creation of the network.
	// default: DockerNetworkStatePresent
	State *DockerNetworkState `json:"state,omitempty"`

	// Restrict external access to the network.
	Internal *bool `json:"internal,omitempty"`

	// Dictionary of labels.
	// default: {}
	Labels *map[string]any `json:"labels,omitempty"`

	// Specify the network's scope.
	Scope *DockerNetworkScope `json:"scope,omitempty"`

	// If enabled, and the network is in the global scope, non-service containers
	// on worker nodes will be able to connect to the network.
	Attachable *bool `json:"attachable,omitempty"`

	// The URL or Unix socket path used to connect to the Docker API. To connect to
	// a remote host, provide the TCP connection string. For example,
	// `tcp://192.0.2.23:2376`. If TLS is used to encrypt the connection, the
	// module will automatically replace `tcp` in the connection URL with `https`.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_HOST` will be used instead. If the environment variable is not set,
	// the default value will be used.
	// default: "unix:///var/run/docker.sock"
	DockerHost *string `json:"docker_host,omitempty"`

	// When verifying the authenticity of the Docker Host server, provide the
	// expected name of the server.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TLS_HOSTNAME` will be used instead. If the environment variable is
	// not set, the default value will be used.
	// Note that this option had a default value `localhost` in older versions. It
	// was removed in community.docker 3.0.0.
	TlsHostname *string `json:"tls_hostname,omitempty"`

	// The version of the Docker API running on the Docker Host.
	// Defaults to the latest version of the API supported by this collection and
	// the docker daemon.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_API_VERSION` will be used instead. If the environment variable is
	// not set, the default value will be used.
	// default: "auto"
	ApiVersion *string `json:"api_version,omitempty"`

	// The maximum amount of time in seconds to wait on a response from the API.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TIMEOUT` will be used instead. If the environment variable is not
	// set, the default value will be used.
	// default: 60
	Timeout *int `json:"timeout,omitempty"`

	// Use a CA certificate when performing server verification by providing the
	// path to a CA certificate file.
	// If the value is not specified in the task and the environment variable
	// `DOCKER_CERT_PATH` is set, the file `ca.pem` from the directory specified in
	// the environment variable `DOCKER_CERT_PATH` will be used.
	// This option was called `ca_cert` and got renamed to `ca_path` in
	// community.docker 3.6.0. The old name has been added as an alias and can
	// still be used.
	CaPath *string `json:"ca_path,omitempty"`

	// Path to the client's TLS certificate file.
	// If the value is not specified in the task and the environment variable
	// `DOCKER_CERT_PATH` is set, the file `cert.pem` from the directory specified
	// in the environment variable `DOCKER_CERT_PATH` will be used.
	ClientCert *string `json:"client_cert,omitempty"`

	// Path to the client's TLS key file.
	// If the value is not specified in the task and the environment variable
	// `DOCKER_CERT_PATH` is set, the file `key.pem` from the directory specified
	// in the environment variable `DOCKER_CERT_PATH` will be used.
	ClientKey *string `json:"client_key,omitempty"`

	// Secure the connection to the API by using TLS without verifying the
	// authenticity of the Docker host server. Note that if `validate_certs` is set
	// to `true` as well, it will take precedence.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TLS` will be used instead. If the environment variable is not set,
	// the default value will be used.
	// default: false
	Tls *bool `json:"tls,omitempty"`

	// For SSH transports, use the `ssh` CLI tool instead of paramiko.
	// default: false
	UseSshClient *bool `json:"use_ssh_client,omitempty"`

	// Secure the connection to the API by using TLS and verifying the authenticity
	// of the Docker host server.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TLS_VERIFY` will be used instead. If the environment variable is not
	// set, the default value will be used.
	// default: false
	ValidateCerts *bool `json:"validate_certs,omitempty"`

	// Debug mode
	// default: false
	Debug *bool `json:"debug,omitempty"`
}

// Wrap the `DockerNetworkParameters into an `rpc.RPCCall`.
func (p DockerNetworkParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := cast.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: DockerNetworkName,
			Args: args,
		},
	}, nil
}

// Return values for the `docker_network` Ansible module.
type DockerNetworkReturn struct {
	AnsibleCommonReturns

	// Network inspection results for the affected network.
	Network *map[string]any `json:"network,omitempty"`
}

// Unwrap the `rpc.RPCResult` into an `DockerNetworkReturn`
func DockerNetworkReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (DockerNetworkReturn, error) {
	return cast.AnyToJSONT[DockerNetworkReturn](r.Result.Result)
}
