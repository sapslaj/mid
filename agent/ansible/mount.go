// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
	"github.com/sapslaj/mid/pkg/cast"
)

// This module controls active and configured mount points in `/etc/fstab`.
const MountName = "mount"

// If `mounted`, the device will be actively mounted and appropriately
// configured in `fstab`. If the mount point is not present, the mount point
// will be created.
// If `unmounted`, the device will be unmounted without changing `fstab`.
// `present` only specifies that the device is to be configured in `fstab` and
// does not trigger or require a mount.
// `ephemeral` only specifies that the device is to be mounted, without changing
// `fstab`. If it is already mounted, a remount will be triggered. This will
// always return R`ignore:changed=true`. If the mount point `path` has already a
// device mounted on, and its source is different than `src`, the module will
// fail to avoid unexpected unmount or mount point override. If the mount point
// is not present, the mount point will be created. The `fstab` is completely
// ignored. This option is added in version 1.5.0.
// `absent` specifies that the mount point entry `path` will be removed from
// `fstab` and will also unmount the mounted device and remove the mount point.
// A mounted device will be unmounted regardless of `src` or its real source.
// `absent` does not unmount recursively, and the module will fail if multiple
// devices are mounted on the same mount point. Using `absent` with a mount
// point that is not registered in the `fstab` has no effect, use `unmounted`
// instead.
// `remounted` specifies that the device will be remounted for when you want to
// force a refresh on the mount itself (added in 2.9). This will always return
// R`ignore:changed=true`. If `opts` is set, the options will be applied to the
// remount, but will not change `fstab`.  Additionally, if `opts` is set, and
// the remount command fails, the module will error to prevent unexpected mount
// changes.  Try using `mounted` instead to work around this issue.  `remounted`
// expects the mount point to be present in the `fstab`. To remount a mount
// point not registered in `fstab`, use `ephemeral` instead, especially with BSD
// nodes.
// `absent_from_fstab` specifies that the device mount's entry will be removed
// from `fstab`. This option does not unmount it or delete the mountpoint.
type MountState string

const (
	MountStateAbsent          MountState = "absent"
	MountStateAbsentFromFstab MountState = "absent_from_fstab"
	MountStateMounted         MountState = "mounted"
	MountStatePresent         MountState = "present"
	MountStateUnmounted       MountState = "unmounted"
	MountStateRemounted       MountState = "remounted"
	MountStateEphemeral       MountState = "ephemeral"
)

// Parameters for the `mount` Ansible module.
type MountParameters struct {
	// Path to the mount point (e.g. `/mnt/files`).
	// Before Ansible 2.3 this option was only usable as `ignore:dest`,
	// `ignore:destfile`, and `name`.
	Path string `json:"path"`

	// Device (or NFS volume, or something else) to be mounted on `path`.
	// Required when `state` set to `present`, `mounted`, or `ephemeral`.
	// Ignored when `state` set to `absent` or `unmounted`.
	Src *string `json:"src,omitempty"`

	// Filesystem type.
	// Required when `state` is `present`, `mounted`, or `ephemeral`.
	Fstype *string `json:"fstype,omitempty"`

	// Mount options (see fstab(5), or vfstab(4) on Solaris).
	Opts *string `json:"opts,omitempty"`

	// Do not log opts.
	// default: false
	OptsNoLog *bool `json:"opts_no_log,omitempty"`

	// Dump (see fstab(5)).
	// Note that if set to `null` and `state=present`, it will cease to work and
	// duplicate entries will be made with subsequent runs.
	// Has no effect on Solaris systems or when used with `state=ephemeral`.
	// default: "0"
	Dump *string `json:"dump,omitempty"`

	// Passno (see fstab(5)).
	// Note that if set to `null` and `state=present`, it will cease to work and
	// duplicate entries will be made with subsequent runs.
	// Deprecated on Solaris systems. Has no effect when used with
	// `state=ephemeral`.
	// default: "0"
	Passno *string `json:"passno,omitempty"`

	// If `mounted`, the device will be actively mounted and appropriately
	// configured in `fstab`. If the mount point is not present, the mount point
	// will be created.
	// If `unmounted`, the device will be unmounted without changing `fstab`.
	// `present` only specifies that the device is to be configured in `fstab` and
	// does not trigger or require a mount.
	// `ephemeral` only specifies that the device is to be mounted, without
	// changing `fstab`. If it is already mounted, a remount will be triggered.
	// This will always return R`ignore:changed=true`. If the mount point `path`
	// has already a device mounted on, and its source is different than `src`, the
	// module will fail to avoid unexpected unmount or mount point override. If the
	// mount point is not present, the mount point will be created. The `fstab` is
	// completely ignored. This option is added in version 1.5.0.
	// `absent` specifies that the mount point entry `path` will be removed from
	// `fstab` and will also unmount the mounted device and remove the mount point.
	// A mounted device will be unmounted regardless of `src` or its real source.
	// `absent` does not unmount recursively, and the module will fail if multiple
	// devices are mounted on the same mount point. Using `absent` with a mount
	// point that is not registered in the `fstab` has no effect, use `unmounted`
	// instead.
	// `remounted` specifies that the device will be remounted for when you want to
	// force a refresh on the mount itself (added in 2.9). This will always return
	// R`ignore:changed=true`. If `opts` is set, the options will be applied to the
	// remount, but will not change `fstab`.  Additionally, if `opts` is set, and
	// the remount command fails, the module will error to prevent unexpected mount
	// changes.  Try using `mounted` instead to work around this issue.
	// `remounted` expects the mount point to be present in the `fstab`. To remount
	// a mount point not registered in `fstab`, use `ephemeral` instead, especially
	// with BSD nodes.
	// `absent_from_fstab` specifies that the device mount's entry will be removed
	// from `fstab`. This option does not unmount it or delete the mountpoint.
	State MountState `json:"state"`

	// File to use instead of `/etc/fstab`.
	// You should not use this option unless you really know what you are doing.
	// This might be useful if you need to configure mountpoints in a chroot
	// environment.
	// OpenBSD does not allow specifying alternate fstab files with mount so do not
	// use this on OpenBSD with any state that operates on the live filesystem.
	// This parameter defaults to `/etc/fstab` or `/etc/vfstab` on Solaris.
	// This parameter is ignored when `state=ephemeral`.
	Fstab *string `json:"fstab,omitempty"`

	// Determines if the filesystem should be mounted on boot.
	// Only applies to Solaris and Linux systems.
	// For Solaris systems, `true` will set `yes` as the value of mount at boot in
	// `/etc/vfstab`.
	// For Linux, FreeBSD, NetBSD and OpenBSD systems, `false` will add `noauto` to
	// mount options in `/etc/fstab`.
	// To avoid mount option conflicts, if `noauto` specified in `opts`, mount
	// module will ignore `boot`.
	// This parameter is ignored when `state=ephemeral`.
	// default: true
	Boot *bool `json:"boot,omitempty"`

	// Create a backup file including the timestamp information so you can get the
	// original file back if you somehow clobbered it incorrectly.
	// default: false
	Backup *bool `json:"backup,omitempty"`
}

// Wrap the `MountParameters into an `rpc.RPCCall`.
func (p MountParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := cast.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: MountName,
			Args: args,
		},
	}, nil
}

// Return values for the `mount` Ansible module.
type MountReturn struct {
	AnsibleCommonReturns
}

// Unwrap the `rpc.RPCResult` into an `MountReturn`
func MountReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (MountReturn, error) {
	return cast.AnyToJSONT[MountReturn](r.Result.Result)
}
