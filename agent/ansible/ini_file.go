// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
	"github.com/sapslaj/mid/pkg/cast"
)

// Manage (add, remove, change) individual settings in an INI-style file without
// having to manage the file as a whole with, say, `ansible.builtin.template` or
// `ansible.builtin.assemble`.
// Adds missing sections if they do not exist.
// This module adds missing ending newlines to files to keep in line with the
// POSIX standard, even when no other modifications need to be applied.
const IniFileName = "ini_file"

// If set to `absent` and `exclusive` set to `true` all matching `option` lines
// are removed.
// If set to `absent` and `exclusive` set to `false` the specified
// `option=value` lines are removed, but the other `option`s with the same name
// are not touched.
// If set to `present` and `exclusive` set to `false` the specified
// `option=values` lines are added, but the other `option`s with the same name
// are not touched.
// If set to `present` and `exclusive` set to `true` all given `option=values`
// lines will be added and the other `option`s with the same name are removed.
type IniFileState string

const (
	IniFileStateAbsent  IniFileState = "absent"
	IniFileStatePresent IniFileState = "present"
)

// Convert a supported type to an optional (pointer) IniFileState
func OptionalIniFileState[T interface {
	*IniFileState | IniFileState | *string | string
}](s T) *IniFileState {
	switch v := any(s).(type) {
	case *IniFileState:
		return v
	case IniFileState:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := IniFileState(*v)
		return &val
	case string:
		val := IniFileState(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `ini_file` Ansible module.
type IniFileParameters struct {
	// Path to the INI-style file; this file is created if required.
	Path string `json:"path"`

	// Section name in INI file. This is added if `state=present` automatically
	// when a single value is being set.
	// If being omitted, the `option` will be placed before the first `section`.
	// Omitting `section` is also required if the config format does not support
	// sections.
	Section *string `json:"section,omitempty"`

	// Among possibly multiple sections of the same name, select the first one that
	// contains matching options and values.
	// With `state=present`, if a suitable section is not found, a new section will
	// be added, including the required options.
	// With `state=absent`, at most one `section` is removed if it contains the
	// values.
	SectionHasValues *struct {
		Option string    `json:"option"`
		Value  *string   `json:"value,omitempty"`
		Values *[]string `json:"values,omitempty"`
	} `json:"section_has_values,omitempty"`

	// If set (required for changing a `value`), this is the name of the option.
	// May be omitted if adding/removing a whole `section`.
	Option *string `json:"option,omitempty"`

	// The string value to be associated with an `option`.
	// May be omitted when removing an `option`.
	// Mutually exclusive with `values`.
	// `value=v` is equivalent to `values=[v]`.
	Value *string `json:"value,omitempty"`

	// The string value to be associated with an `option`.
	// May be omitted when removing an `option`.
	// Mutually exclusive with `value`.
	// `value=v` is equivalent to `values=[v]`.
	Values *[]string `json:"values,omitempty"`

	// Create a backup file including the timestamp information so you can get the
	// original file back if you somehow clobbered it incorrectly.
	// default: false
	Backup *bool `json:"backup,omitempty"`

	// If set to `absent` and `exclusive` set to `true` all matching `option` lines
	// are removed.
	// If set to `absent` and `exclusive` set to `false` the specified
	// `option=value` lines are removed, but the other `option`s with the same name
	// are not touched.
	// If set to `present` and `exclusive` set to `false` the specified
	// `option=values` lines are added, but the other `option`s with the same name
	// are not touched.
	// If set to `present` and `exclusive` set to `true` all given `option=values`
	// lines will be added and the other `option`s with the same name are removed.
	// default: IniFileStatePresent
	State *IniFileState `json:"state,omitempty"`

	// If set to `true` (default), all matching `option` lines are removed when
	// `state=absent`, or replaced when `state=present`.
	// If set to `false`, only the specified `value`/`values` are added when
	// `state=present`, or removed when `state=absent`, and existing ones are not
	// modified.
	// default: true
	Exclusive *bool `json:"exclusive,omitempty"`

	// Do not insert spaces before and after '=' symbol.
	// default: false
	NoExtraSpaces *bool `json:"no_extra_spaces,omitempty"`

	// Do not change a line if doing so would only add or remove spaces before or
	// after the `=` symbol.
	// default: false
	IgnoreSpaces *bool `json:"ignore_spaces,omitempty"`

	// If set to `false`, the module will fail if the file does not already exist.
	// By default it will create the file if it is missing.
	// default: true
	Create *bool `json:"create,omitempty"`

	// Allow option without value and without '=' symbol.
	// default: false
	AllowNoValue *bool `json:"allow_no_value,omitempty"`

	// By default the module replaces a commented line that matches the given
	// option.
	// Set this option to `false` to avoid this. This is useful when you want to
	// keep commented example `key=value` pairs for documentation purposes.
	// default: true
	ModifyInactiveOption *bool `json:"modify_inactive_option,omitempty"`

	// This flag indicates that filesystem links, if they exist, should be
	// followed.
	// `follow=true` can modify `path` when combined with parameters such as
	// `mode`.
	// default: false
	Follow *bool `json:"follow,omitempty"`

	// The permissions the resulting filesystem object should have.
	// For those used to `/usr/bin/chmod` remember that modes are actually octal
	// numbers. You must give Ansible enough information to parse them correctly.
	// For consistent results, quote octal numbers (for example, `'644'` or
	// `'1777'`) so Ansible receives a string and can do its own conversion from
	// string into number. Adding a leading zero (for example, `0755`) works
	// sometimes, but can fail in loops and some other circumstances.
	// Giving Ansible a number without following either of these rules will end up
	// with a decimal number which will have unexpected results.
	// As of Ansible 1.8, the mode may be specified as a symbolic mode (for
	// example, `u+rwx` or `u=rw,g=r,o=r`).
	// If `mode` is not specified and the destination filesystem object `does not`
	// exist, the default `umask` on the system will be used when setting the mode
	// for the newly created filesystem object.
	// If `mode` is not specified and the destination filesystem object `does`
	// exist, the mode of the existing filesystem object will be used.
	// Specifying `mode` is the best way to ensure filesystem objects are created
	// with the correct permissions. See CVE-2020-1736 for further details.
	Mode *any `json:"mode,omitempty"`

	// Name of the user that should own the filesystem object, as would be fed to
	// `chown`.
	// When left unspecified, it uses the current user unless you are root, in
	// which case it can preserve the previous ownership.
	// Specifying a numeric username will be assumed to be a user ID and not a
	// username. Avoid numeric usernames to avoid this confusion.
	Owner *string `json:"owner,omitempty"`

	// Name of the group that should own the filesystem object, as would be fed to
	// `chown`.
	// When left unspecified, it uses the current group of the current user unless
	// you are root, in which case it can preserve the previous ownership.
	Group *string `json:"group,omitempty"`

	// The user part of the SELinux filesystem object context.
	// By default it uses the `system` policy, where applicable.
	// When set to `_default`, it will use the `user` portion of the policy if
	// available.
	Seuser *string `json:"seuser,omitempty"`

	// The role part of the SELinux filesystem object context.
	// When set to `_default`, it will use the `role` portion of the policy if
	// available.
	Serole *string `json:"serole,omitempty"`

	// The type part of the SELinux filesystem object context.
	// When set to `_default`, it will use the `type` portion of the policy if
	// available.
	Setype *string `json:"setype,omitempty"`

	// The level part of the SELinux filesystem object context.
	// This is the MLS/MCS attribute, sometimes known as the `range`.
	// When set to `_default`, it will use the `level` portion of the policy if
	// available.
	Selevel *string `json:"selevel,omitempty"`

	// Influence when to use atomic operation to prevent data corruption or
	// inconsistent reads from the target filesystem object.
	// By default this module uses atomic operations to prevent data corruption or
	// inconsistent reads from the target filesystem objects, but sometimes systems
	// are configured or just broken in ways that prevent this. One example is
	// docker mounted filesystem objects, which cannot be updated atomically from
	// inside the container and can only be written in an unsafe manner.
	// This option allows Ansible to fall back to unsafe methods of updating
	// filesystem objects when atomic operations fail (however, it doesn't force
	// Ansible to perform unsafe writes).
	// IMPORTANT! Unsafe writes are subject to race conditions and can lead to data
	// corruption.
	// default: false
	UnsafeWrites *bool `json:"unsafe_writes,omitempty"`

	// The attributes the resulting filesystem object should have.
	// To get supported flags look at the man page for `chattr` on the target
	// system.
	// This string should contain the attributes in the same order as the one
	// displayed by `lsattr`.
	// The `=` operator is assumed as default, otherwise `+` or `-` operators need
	// to be included in the string.
	Attributes *string `json:"attributes,omitempty"`
}

// Wrap the `IniFileParameters into an `rpc.RPCCall`.
func (p IniFileParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := cast.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: IniFileName,
			Args: args,
		},
	}, nil
}

// Return values for the `ini_file` Ansible module.
type IniFileReturn struct {
	AnsibleCommonReturns
}

// Unwrap the `rpc.RPCResult` into an `IniFileReturn`
func IniFileReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (IniFileReturn, error) {
	return cast.AnyToJSONT[IniFileReturn](r.Result.Result)
}
