// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package resource

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/sapslaj/mid/sdk/go/mid/internal"
	"github.com/sapslaj/mid/sdk/go/mid/types"
)

type User struct {
	pulumi.CustomResourceState

	Comment         pulumi.StringPtrOutput     `pulumi:"comment"`
	Ensure          pulumi.StringPtrOutput     `pulumi:"ensure"`
	Force           pulumi.BoolPtrOutput       `pulumi:"force"`
	Group           pulumi.StringPtrOutput     `pulumi:"group"`
	Groups          pulumi.StringArrayOutput   `pulumi:"groups"`
	GroupsExclusive pulumi.BoolPtrOutput       `pulumi:"groupsExclusive"`
	Home            pulumi.StringPtrOutput     `pulumi:"home"`
	Local           pulumi.BoolPtrOutput       `pulumi:"local"`
	ManageHome      pulumi.BoolPtrOutput       `pulumi:"manageHome"`
	Name            pulumi.StringOutput        `pulumi:"name"`
	NonUnique       pulumi.BoolPtrOutput       `pulumi:"nonUnique"`
	Password        pulumi.StringPtrOutput     `pulumi:"password"`
	Shell           pulumi.StringPtrOutput     `pulumi:"shell"`
	Skeleton        pulumi.StringPtrOutput     `pulumi:"skeleton"`
	System          pulumi.BoolPtrOutput       `pulumi:"system"`
	Triggers        types.TriggersOutputOutput `pulumi:"triggers"`
	Uid             pulumi.IntPtrOutput        `pulumi:"uid"`
	UidMax          pulumi.IntPtrOutput        `pulumi:"uidMax"`
	UidMin          pulumi.IntPtrOutput        `pulumi:"uidMin"`
	Umask           pulumi.StringPtrOutput     `pulumi:"umask"`
	UpdatePassword  pulumi.StringPtrOutput     `pulumi:"updatePassword"`
}

// NewUser registers a new resource with the given unique name, arguments, and options.
func NewUser(ctx *pulumi.Context,
	name string, args *UserArgs, opts ...pulumi.ResourceOption) (*User, error) {
	if args == nil {
		args = &UserArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource User
	err := ctx.RegisterResource("mid:resource:User", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetUser gets an existing User resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetUser(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *UserState, opts ...pulumi.ResourceOption) (*User, error) {
	var resource User
	err := ctx.ReadResource("mid:resource:User", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering User resources.
type userState struct {
}

type UserState struct {
}

func (UserState) ElementType() reflect.Type {
	return reflect.TypeOf((*userState)(nil)).Elem()
}

type userArgs struct {
	Comment         *string              `pulumi:"comment"`
	Ensure          *string              `pulumi:"ensure"`
	Force           *bool                `pulumi:"force"`
	Group           *string              `pulumi:"group"`
	Groups          []string             `pulumi:"groups"`
	GroupsExclusive *bool                `pulumi:"groupsExclusive"`
	Home            *string              `pulumi:"home"`
	Local           *bool                `pulumi:"local"`
	ManageHome      *bool                `pulumi:"manageHome"`
	Name            *string              `pulumi:"name"`
	NonUnique       *bool                `pulumi:"nonUnique"`
	Password        *string              `pulumi:"password"`
	Shell           *string              `pulumi:"shell"`
	Skeleton        *string              `pulumi:"skeleton"`
	System          *bool                `pulumi:"system"`
	Triggers        *types.TriggersInput `pulumi:"triggers"`
	Uid             *int                 `pulumi:"uid"`
	UidMax          *int                 `pulumi:"uidMax"`
	UidMin          *int                 `pulumi:"uidMin"`
	Umask           *string              `pulumi:"umask"`
	UpdatePassword  *string              `pulumi:"updatePassword"`
}

// The set of arguments for constructing a User resource.
type UserArgs struct {
	Comment         pulumi.StringPtrInput
	Ensure          pulumi.StringPtrInput
	Force           pulumi.BoolPtrInput
	Group           pulumi.StringPtrInput
	Groups          pulumi.StringArrayInput
	GroupsExclusive pulumi.BoolPtrInput
	Home            pulumi.StringPtrInput
	Local           pulumi.BoolPtrInput
	ManageHome      pulumi.BoolPtrInput
	Name            pulumi.StringPtrInput
	NonUnique       pulumi.BoolPtrInput
	Password        pulumi.StringPtrInput
	Shell           pulumi.StringPtrInput
	Skeleton        pulumi.StringPtrInput
	System          pulumi.BoolPtrInput
	Triggers        types.TriggersInputPtrInput
	Uid             pulumi.IntPtrInput
	UidMax          pulumi.IntPtrInput
	UidMin          pulumi.IntPtrInput
	Umask           pulumi.StringPtrInput
	UpdatePassword  pulumi.StringPtrInput
}

func (UserArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*userArgs)(nil)).Elem()
}

type UserInput interface {
	pulumi.Input

	ToUserOutput() UserOutput
	ToUserOutputWithContext(ctx context.Context) UserOutput
}

func (*User) ElementType() reflect.Type {
	return reflect.TypeOf((**User)(nil)).Elem()
}

func (i *User) ToUserOutput() UserOutput {
	return i.ToUserOutputWithContext(context.Background())
}

func (i *User) ToUserOutputWithContext(ctx context.Context) UserOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserOutput)
}

// UserArrayInput is an input type that accepts UserArray and UserArrayOutput values.
// You can construct a concrete instance of `UserArrayInput` via:
//
//	UserArray{ UserArgs{...} }
type UserArrayInput interface {
	pulumi.Input

	ToUserArrayOutput() UserArrayOutput
	ToUserArrayOutputWithContext(context.Context) UserArrayOutput
}

type UserArray []UserInput

func (UserArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*User)(nil)).Elem()
}

func (i UserArray) ToUserArrayOutput() UserArrayOutput {
	return i.ToUserArrayOutputWithContext(context.Background())
}

func (i UserArray) ToUserArrayOutputWithContext(ctx context.Context) UserArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserArrayOutput)
}

// UserMapInput is an input type that accepts UserMap and UserMapOutput values.
// You can construct a concrete instance of `UserMapInput` via:
//
//	UserMap{ "key": UserArgs{...} }
type UserMapInput interface {
	pulumi.Input

	ToUserMapOutput() UserMapOutput
	ToUserMapOutputWithContext(context.Context) UserMapOutput
}

type UserMap map[string]UserInput

func (UserMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*User)(nil)).Elem()
}

func (i UserMap) ToUserMapOutput() UserMapOutput {
	return i.ToUserMapOutputWithContext(context.Background())
}

func (i UserMap) ToUserMapOutputWithContext(ctx context.Context) UserMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserMapOutput)
}

type UserOutput struct{ *pulumi.OutputState }

func (UserOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**User)(nil)).Elem()
}

func (o UserOutput) ToUserOutput() UserOutput {
	return o
}

func (o UserOutput) ToUserOutputWithContext(ctx context.Context) UserOutput {
	return o
}

func (o UserOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *User) pulumi.StringPtrOutput { return v.Comment }).(pulumi.StringPtrOutput)
}

func (o UserOutput) Ensure() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *User) pulumi.StringPtrOutput { return v.Ensure }).(pulumi.StringPtrOutput)
}

func (o UserOutput) Force() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *User) pulumi.BoolPtrOutput { return v.Force }).(pulumi.BoolPtrOutput)
}

func (o UserOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *User) pulumi.StringPtrOutput { return v.Group }).(pulumi.StringPtrOutput)
}

func (o UserOutput) Groups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *User) pulumi.StringArrayOutput { return v.Groups }).(pulumi.StringArrayOutput)
}

func (o UserOutput) GroupsExclusive() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *User) pulumi.BoolPtrOutput { return v.GroupsExclusive }).(pulumi.BoolPtrOutput)
}

func (o UserOutput) Home() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *User) pulumi.StringPtrOutput { return v.Home }).(pulumi.StringPtrOutput)
}

func (o UserOutput) Local() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *User) pulumi.BoolPtrOutput { return v.Local }).(pulumi.BoolPtrOutput)
}

func (o UserOutput) ManageHome() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *User) pulumi.BoolPtrOutput { return v.ManageHome }).(pulumi.BoolPtrOutput)
}

func (o UserOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *User) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o UserOutput) NonUnique() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *User) pulumi.BoolPtrOutput { return v.NonUnique }).(pulumi.BoolPtrOutput)
}

func (o UserOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *User) pulumi.StringPtrOutput { return v.Password }).(pulumi.StringPtrOutput)
}

func (o UserOutput) Shell() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *User) pulumi.StringPtrOutput { return v.Shell }).(pulumi.StringPtrOutput)
}

func (o UserOutput) Skeleton() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *User) pulumi.StringPtrOutput { return v.Skeleton }).(pulumi.StringPtrOutput)
}

func (o UserOutput) System() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *User) pulumi.BoolPtrOutput { return v.System }).(pulumi.BoolPtrOutput)
}

func (o UserOutput) Triggers() types.TriggersOutputOutput {
	return o.ApplyT(func(v *User) types.TriggersOutputOutput { return v.Triggers }).(types.TriggersOutputOutput)
}

func (o UserOutput) Uid() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *User) pulumi.IntPtrOutput { return v.Uid }).(pulumi.IntPtrOutput)
}

func (o UserOutput) UidMax() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *User) pulumi.IntPtrOutput { return v.UidMax }).(pulumi.IntPtrOutput)
}

func (o UserOutput) UidMin() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *User) pulumi.IntPtrOutput { return v.UidMin }).(pulumi.IntPtrOutput)
}

func (o UserOutput) Umask() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *User) pulumi.StringPtrOutput { return v.Umask }).(pulumi.StringPtrOutput)
}

func (o UserOutput) UpdatePassword() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *User) pulumi.StringPtrOutput { return v.UpdatePassword }).(pulumi.StringPtrOutput)
}

type UserArrayOutput struct{ *pulumi.OutputState }

func (UserArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*User)(nil)).Elem()
}

func (o UserArrayOutput) ToUserArrayOutput() UserArrayOutput {
	return o
}

func (o UserArrayOutput) ToUserArrayOutputWithContext(ctx context.Context) UserArrayOutput {
	return o
}

func (o UserArrayOutput) Index(i pulumi.IntInput) UserOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *User {
		return vs[0].([]*User)[vs[1].(int)]
	}).(UserOutput)
}

type UserMapOutput struct{ *pulumi.OutputState }

func (UserMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*User)(nil)).Elem()
}

func (o UserMapOutput) ToUserMapOutput() UserMapOutput {
	return o
}

func (o UserMapOutput) ToUserMapOutputWithContext(ctx context.Context) UserMapOutput {
	return o
}

func (o UserMapOutput) MapIndex(k pulumi.StringInput) UserOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *User {
		return vs[0].(map[string]*User)[vs[1].(string)]
	}).(UserOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*UserInput)(nil)).Elem(), &User{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserArrayInput)(nil)).Elem(), UserArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserMapInput)(nil)).Elem(), UserMap{})
	pulumi.RegisterOutputType(UserOutput{})
	pulumi.RegisterOutputType(UserArrayOutput{})
	pulumi.RegisterOutputType(UserMapOutput{})
}
