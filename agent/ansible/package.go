// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
)

// This modules manages packages on a target without specifying a package
// manager module (like `ansible.builtin.dnf`, `ansible.builtin.apt`, ...). It
// is convenient to use in an heterogeneous environment of machines without
// having to create a specific task for each package manager.
// `ansible.builtin.package` calls behind the module for the package manager
// used by the operating system discovered by the module
// `ansible.builtin.setup`.  If `ansible.builtin.setup` was not yet run,
// `ansible.builtin.package` will run it.
// This module acts as a proxy to the underlying package manager module. While
// all arguments will be passed to the underlying module, not all modules
// support the same arguments. This documentation only covers the minimum
// intersection of module arguments that all packaging modules support.
// For Windows targets, use the `ansible.windows.win_package` module instead.
const PackageName = "package"

// Parameters for the `package` Ansible module.
type PackageParameters struct {
	// Package name, or package specifier with version.
	// Syntax varies with package manager. For example `name-1.0` or `name=1.0`.
	// Package names also vary with package manager; this module will not
	// "translate" them per distribution. For example `libyaml-dev`, `libyaml-
	// devel`.
	// To operate on several packages this can accept a comma separated string of
	// packages or a list of packages, depending on the underlying package manager.
	Name any `json:"name"`

	// Whether to install (`present`), or remove (`absent`) a package.
	// You can use other states like `latest` ONLY if they are supported by the
	// underlying package module(s) executed.
	State string `json:"state"`

	// The required package manager module to use (`dnf`, `apt`, and so on). The
	// default `auto` will use existing facts or try to auto-detect it.
	// You should only use this field if the automatic selection is not working for
	// some reason.
	// Since version 2.17 you can use the `ansible_package_use` variable to
	// override the automatic detection, but this option still takes precedence.
	// default: "auto"
	Use *string `json:"use,omitempty"`
}

// Wrap the `PackageParameters into an `rpc.RPCCall`.
func (p *PackageParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := rpc.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: PackageName,
			Args: args,
		},
	}, nil
}

// Return values for the `package` Ansible module.
type PackageReturn struct {
	AnsibleCommonReturns
}

// Unwrap the `rpc.RPCResult` into an `PackageReturn`
func PackageReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (PackageReturn, error) {
	return rpc.AnyToJSONT[PackageReturn](r.Result.Result)
}
