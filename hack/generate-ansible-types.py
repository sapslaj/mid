#!/usr/bin/env python3
from io import StringIO
import multiprocessing
import os
import pathlib
import re
import sys
from typing import Any
from importlib import import_module
import textwrap

import deepmerge
import yaml

agent_dir = pathlib.Path(__file__).parent / ".." / "agent"
ansible_dir = pathlib.Path(__file__).parent / ".." / "ansible"

sys.path.insert(0, str(ansible_dir.parent.absolute().resolve(True)))


def pascalcased(s: str) -> str:
    return "".join([word.capitalize() for word in s.split("_")])


def yaml_loads(data: Any) -> Any:
    yaml.safe_load(StringIO(data))
    return


def unmarkup(s: str) -> str:
    return re.sub(r"[A-Z]\((.+?)\)", r"`\1`", s)


def doc_comment(paragraphs: list[str] | str, indent: int) -> str:
    if isinstance(paragraphs, str):
        paragraphs = [paragraphs]
    indent_text = ("\t" * indent) + "// "
    result = ""
    for para in paragraphs:
        lines = textwrap.wrap(
            text=unmarkup(para),
            width=80,
            initial_indent=indent_text,
            subsequent_indent=indent_text,
        )
        for line in lines:
            result += line + "\n"
    return result.rstrip() + "\n"


def scalar_type_ansible_to_go(t: str) -> str:
    match t:
        case "str":
            return "string"
        case "path":
            return "string"
        case "bool":
            return "bool"
        case "int":
            return "int"
        case "raw":
            # TODO: should this be a string instead or something?
            return "any"
        case "float":
            return "float64"
        case _:
            raise Exception(f"unknown type '{t}'")


def composite_type_ansible_to_go(obj: Any) -> str:
    typ = obj.get("type", "str")
    match typ:
        case "complex":
            # TODO: handle this better
            return "any"
        case "list":
            elements = obj.get("elements", None)
            if not elements:
                return "[]any"
            return "[]" + scalar_type_ansible_to_go(elements)
        case "dict":
            if obj.get("elements", None) is not None:
                raise Exception("dict has subelements???")
            suboptions = obj.get("suboptions", None)
            if not suboptions:
                return "map[string]any"
            result = "struct {"
            for key, value in suboptions.items():
                required = value.get("required", False)
                result += "\t\t"
                result += pascalcased(key)
                result += " "
                if not required:
                    result += "*"
                result += composite_type_ansible_to_go(value)
                result += ' `json:"'
                result += key
                if not required:
                    result += ",omitempty"
                result += '"`\n'

            result += "\t}"
            return result
        case _:
            return scalar_type_ansible_to_go(typ)


def process_module_file(module_file: str):
    if module_file.startswith("_"):
        return
    name = os.path.splitext(module_file)[0]
    print(name)

    module_fqn = f"ansible.modules.{name}"

    module = import_module(module_fqn)
    documentation = yaml.safe_load(StringIO(getattr(module, "DOCUMENTATION")))
    returns = yaml.safe_load(StringIO(getattr(module, "RETURN", "{}")))
    if returns is None:
        returns = dict()
    extends_documentation_fragments = documentation.get(
        "extends_documentation_fragment", []
    )
    if isinstance(extends_documentation_fragments, str):
        extends_documentation_fragments = [extends_documentation_fragments]
    for extends_documentation_fragment in extends_documentation_fragments:
        doc_fragment_module = import_module(
            f"ansible.plugins.doc_fragments.{extends_documentation_fragment}"
        )
        doc_fragment_class = getattr(doc_fragment_module, "ModuleDocFragment", None)
        if doc_fragment_class is None:
            continue
        doc_fragment = yaml.safe_load(
            StringIO(getattr(doc_fragment_class, "DOCUMENTATION"))
        )
        documentation = deepmerge.always_merger.merge(documentation, doc_fragment)

    pascalcase_name = pascalcased(name)

    with open(agent_dir / "ansible" / f"{name}.go", "w") as f:
        f.write("// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT\n")
        f.write("package ansible\n\n")
        f.write("import (\n")
        f.write('\t"github.com/sapslaj/mid/agent/rpc"\n')
        f.write(")\n\n")
        f.write(doc_comment(documentation["description"], indent=0))
        f.write(f'const {pascalcase_name}Name = "{name}"\n\n')
        f.write(doc_comment(f"Parameters for the `{name}` Ansible module.", indent=0))
        f.write(f"type {pascalcase_name}Parameters struct {'{'}\n")
        for key, value in documentation["options"].items():
            required = value.get("required", False)
            f.write(doc_comment(value["description"], indent=1))
            f.write("\t")
            f.write(pascalcased(key))
            f.write(" ")
            if not required:
                f.write("*")
            f.write(composite_type_ansible_to_go(value))
            f.write(' `json:"')
            f.write(key)
            if not required:
                f.write(",omitempty")
            f.write('"`\n\n')
        f.write("}\n\n")
        f.write("")
        f.write(
            doc_comment(
                f"Wrap the `{pascalcase_name}Parameters into an `rpc.RPCCall`.",
                indent=0,
            )
        )
        f.write(
            f"func (p *{pascalcase_name}Parameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {'{'}\n"
        )
        f.write("\targs, err := rpc.AnyToJSONT[map[string]any](p)\n")
        f.write("\tif err != nil {\n")
        f.write("\t\treturn rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err\n")
        f.write("\t}\n")
        f.write("\treturn rpc.RPCCall[rpc.AnsibleExecuteArgs]{\n")
        f.write("\t\tRPCFunction: rpc.RPCAnsibleExecute,\n")
        f.write("\t\tArgs: rpc.AnsibleExecuteArgs{\n")
        f.write(f"\t\t\tName: {pascalcase_name}Name,\n")
        f.write("\t\t\tArgs: args,\n")
        f.write("\t\t},\n")
        f.write("\t}, nil\n")
        f.write("}\n\n")
        f.write(
            doc_comment(f"Return values for the `{name}` Ansible module.", indent=0)
        )
        f.write(f"type {pascalcase_name}Return struct {'{'}\n")
        f.write("\tAnsibleCommonReturns\n\n")
        for key, value in returns.items():
            f.write(doc_comment(value["description"], indent=1))
            f.write("\t")
            f.write(pascalcased(key))
            f.write(" *")
            f.write(composite_type_ansible_to_go(value))
            f.write(' `json:"')
            f.write(key)
            f.write(",omitempty")
            f.write('"`\n\n')
        f.write("}\n\n")
        f.write(
            doc_comment(
                f"Unwrap the `rpc.RPCResult` into an `{pascalcase_name}Return`",
                indent=0,
            )
        )
        f.write(
            f"func {pascalcase_name}ReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) ({pascalcase_name}Return, error) {'{'}\n"
        )
        f.write(f"\treturn rpc.AnyToJSONT[{pascalcase_name}Return](r.Result.Result)\n")
        f.write("}\n")


def main():
    module_files = os.listdir(ansible_dir / "modules")
    with multiprocessing.Pool(os.process_cpu_count()) as p:
        p.map(process_module_file, module_files)


if __name__ == "__main__":
    main()
