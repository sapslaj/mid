// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
	"github.com/sapslaj/mid/pkg/cast"
)

// Manage docker stacks using the `docker stack` command on the target node (see
// examples).
const DockerStackName = "docker_stack"

// Service state.
type DockerStackState string

const (
	DockerStackStatePresent DockerStackState = "present"
	DockerStackStateAbsent  DockerStackState = "absent"
)

// Convert a supported type to an optional (pointer) DockerStackState
func OptionalDockerStackState[T interface {
	*DockerStackState | DockerStackState | *string | string
}](s T) *DockerStackState {
	switch v := any(s).(type) {
	case *DockerStackState:
		return v
	case DockerStackState:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := DockerStackState(*v)
		return &val
	case string:
		val := DockerStackState(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// If set will add the `--resolve-image` option to the `docker stack deploy`
// command. This will have docker query the registry to resolve image digest and
// supported platforms. If not set, docker use "always" by default.
type DockerStackResolveImage string

const (
	DockerStackResolveImageAlways  DockerStackResolveImage = "always"
	DockerStackResolveImageChanged DockerStackResolveImage = "changed"
	DockerStackResolveImageNever   DockerStackResolveImage = "never"
)

// Convert a supported type to an optional (pointer) DockerStackResolveImage
func OptionalDockerStackResolveImage[T interface {
	*DockerStackResolveImage | DockerStackResolveImage | *string | string
}](s T) *DockerStackResolveImage {
	switch v := any(s).(type) {
	case *DockerStackResolveImage:
		return v
	case DockerStackResolveImage:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := DockerStackResolveImage(*v)
		return &val
	case string:
		val := DockerStackResolveImage(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `docker_stack` Ansible module.
type DockerStackParameters struct {
	// Stack name.
	Name string `json:"name"`

	// Service state.
	// default: DockerStackStatePresent
	State *DockerStackState `json:"state,omitempty"`

	// List of compose definitions. Any element may be a string referring to the
	// path of the compose file on the target host or the YAML contents of a
	// compose file nested as dictionary.
	// default: []
	Compose *[]any `json:"compose,omitempty"`

	// If true will add the `--prune` option to the `docker stack deploy` command.
	// This will have docker remove the services not present in the current stack
	// definition.
	// default: false
	Prune *bool `json:"prune,omitempty"`

	// If `false`, the `--detach=false` option is added to the `docker stack
	// deploy` command, allowing Docker to wait for tasks to converge before
	// exiting.
	// If `true` (default), Docker exits immediately instead of waiting for tasks
	// to converge.
	// default: true
	Detach *bool `json:"detach,omitempty"`

	// If true will add the `--with-registry-auth` option to the `docker stack
	// deploy` command. This will have docker send registry authentication details
	// to Swarm agents.
	// default: false
	WithRegistryAuth *bool `json:"with_registry_auth,omitempty"`

	// If set will add the `--resolve-image` option to the `docker stack deploy`
	// command. This will have docker query the registry to resolve image digest
	// and supported platforms. If not set, docker use "always" by default.
	ResolveImage *DockerStackResolveImage `json:"resolve_image,omitempty"`

	// If larger than `0` and `state=absent` the module will retry up to
	// `absent_retries` times to delete the stack until all the resources have been
	// effectively deleted. If the last try still reports the stack as not
	// completely removed the module will fail.
	// default: 0
	AbsentRetries *int `json:"absent_retries,omitempty"`

	// Interval in seconds between consecutive `absent_retries`.
	// default: 1
	AbsentRetriesInterval *int `json:"absent_retries_interval,omitempty"`

	// Path to the Docker CLI. If not provided, will search for Docker CLI on the
	// `PATH`.
	DockerCli *string `json:"docker_cli,omitempty"`

	// The URL or Unix socket path used to connect to the Docker API. To connect to
	// a remote host, provide the TCP connection string. For example,
	// `tcp://192.0.2.23:2376`. If TLS is used to encrypt the connection, the
	// module will automatically replace `tcp` in the connection URL with `https`.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_HOST` will be used instead. If the environment variable is not set,
	// the default value will be used.
	// Mutually exclusive with `cli_context`. If neither `docker_host` nor
	// `cli_context` are provided, the value `unix:///var/run/docker.sock` is used.
	DockerHost *string `json:"docker_host,omitempty"`

	// When verifying the authenticity of the Docker Host server, provide the
	// expected name of the server.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TLS_HOSTNAME` will be used instead. If the environment variable is
	// not set, the default value will be used.
	TlsHostname *string `json:"tls_hostname,omitempty"`

	// The version of the Docker API running on the Docker Host.
	// Defaults to the latest version of the API supported by this collection and
	// the docker daemon.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_API_VERSION` will be used instead. If the environment variable is
	// not set, the default value will be used.
	// default: "auto"
	ApiVersion *string `json:"api_version,omitempty"`

	// Use a CA certificate when performing server verification by providing the
	// path to a CA certificate file.
	// If the value is not specified in the task and the environment variable
	// `DOCKER_CERT_PATH` is set, the file `ca.pem` from the directory specified in
	// the environment variable `DOCKER_CERT_PATH` will be used.
	CaPath *string `json:"ca_path,omitempty"`

	// Path to the client's TLS certificate file.
	// If the value is not specified in the task and the environment variable
	// `DOCKER_CERT_PATH` is set, the file `cert.pem` from the directory specified
	// in the environment variable `DOCKER_CERT_PATH` will be used.
	ClientCert *string `json:"client_cert,omitempty"`

	// Path to the client's TLS key file.
	// If the value is not specified in the task and the environment variable
	// `DOCKER_CERT_PATH` is set, the file `key.pem` from the directory specified
	// in the environment variable `DOCKER_CERT_PATH` will be used.
	ClientKey *string `json:"client_key,omitempty"`

	// Secure the connection to the API by using TLS without verifying the
	// authenticity of the Docker host server. Note that if `validate_certs` is set
	// to `true` as well, it will take precedence.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TLS` will be used instead. If the environment variable is not set,
	// the default value will be used.
	// default: false
	Tls *bool `json:"tls,omitempty"`

	// Secure the connection to the API by using TLS and verifying the authenticity
	// of the Docker host server.
	// If the value is not specified in the task, the value of environment variable
	// `DOCKER_TLS_VERIFY` will be used instead. If the environment variable is not
	// set, the default value will be used.
	// default: false
	ValidateCerts *bool `json:"validate_certs,omitempty"`

	// The Docker CLI context to use.
	// Mutually exclusive with `docker_host`.
	CliContext *string `json:"cli_context,omitempty"`
}

// Wrap the `DockerStackParameters into an `rpc.RPCCall`.
func (p DockerStackParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := cast.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: DockerStackName,
			Args: args,
		},
	}, nil
}

// Return values for the `docker_stack` Ansible module.
type DockerStackReturn struct {
	AnsibleCommonReturns

	// Dictionary containing the differences between the 'Spec' field of the stack
	// services before and after applying the new stack definition.
	StackSpecDiff *map[string]any `json:"stack_spec_diff,omitempty"`
}

// Unwrap the `rpc.RPCResult` into an `DockerStackReturn`
func DockerStackReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (DockerStackReturn, error) {
	return cast.AnyToJSONT[DockerStackReturn](r.Result.Result)
}
