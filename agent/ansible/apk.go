// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
)

// Manages `apk` packages for Alpine Linux.
const ApkName = "apk"

// Indicates the desired package(s) state.
// `present` ensures the package(s) is/are present. `installed` can be used as
// an alias.
// `absent` ensures the package(s) is/are absent. `removed` can be used as an
// alias.
// `latest` ensures the package(s) is/are present and the latest version(s).
type ApkState string

const (
	ApkStatePresent   ApkState = "present"
	ApkStateAbsent    ApkState = "absent"
	ApkStateLatest    ApkState = "latest"
	ApkStateInstalled ApkState = "installed"
	ApkStateRemoved   ApkState = "removed"
)

func OptionalApkState[T interface {
	*ApkState | ApkState | *string | string
}](s T) *ApkState {
	switch v := any(s).(type) {
	case *ApkState:
		return v
	case ApkState:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := ApkState(*v)
		return &val
	case string:
		val := ApkState(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `apk` Ansible module.
type ApkParameters struct {
	// During upgrade, reset versioned world dependencies and change logic to
	// prefer replacing or downgrading packages (instead of holding them) if the
	// currently installed package is no longer available from any repository.
	// default: false
	Available *bool `json:"available,omitempty"`

	// A package name, like `foo`, or multiple packages, like `foo,bar`.
	// Do not include additional whitespace when specifying multiple packages as a
	// string. Prefer YAML lists over comma-separating multiple package names.
	Name *[]string `json:"name,omitempty"`

	// Do not use any local cache path.
	// default: false
	NoCache *bool `json:"no_cache,omitempty"`

	// A package repository or multiple repositories. Unlike with the underlying
	// apk command, this list will override the system repositories rather than
	// supplement them.
	Repository *[]string `json:"repository,omitempty"`

	// Indicates the desired package(s) state.
	// `present` ensures the package(s) is/are present. `installed` can be used as
	// an alias.
	// `absent` ensures the package(s) is/are absent. `removed` can be used as an
	// alias.
	// `latest` ensures the package(s) is/are present and the latest version(s).
	// default: ApkStatePresent
	State *ApkState `json:"state,omitempty"`

	// Update repository indexes. Can be run with other steps or on its own.
	// default: false
	UpdateCache *bool `json:"update_cache,omitempty"`

	// Upgrade all installed packages to their latest version.
	// default: false
	Upgrade *bool `json:"upgrade,omitempty"`

	// Use a custom world file when checking for explicitly installed packages. The
	// file is used only when a value is provided for `name`, and `state` is set to
	// `present` or `latest`.
	// default: "/etc/apk/world"
	World *string `json:"world,omitempty"`
}

// Wrap the `ApkParameters into an `rpc.RPCCall`.
func (p *ApkParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := rpc.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: ApkName,
			Args: args,
		},
	}, nil
}

// Return values for the `apk` Ansible module.
type ApkReturn struct {
	AnsibleCommonReturns

	// A list of packages that have been changed.
	Packages *[]any `json:"packages,omitempty"`
}

// Unwrap the `rpc.RPCResult` into an `ApkReturn`
func ApkReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (ApkReturn, error) {
	return rpc.AnyToJSONT[ApkReturn](r.Result.Result)
}
