// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
)

// The `ansible.builtin.copy` module copies a file or a directory structure from
// the local or remote machine to a location on the remote machine. File system
// meta-information (permissions, ownership, etc.) may be set, even when the
// file or directory already exists on the target system. Some meta-information
// may be copied on request.
// Get meta-information with the `ansible.builtin.stat` module.
// Set meta-information with the `ansible.builtin.file` module.
// Use the `ansible.builtin.fetch` module to copy files from remote locations to
// the local box.
// If you need variable interpolation in copied files, use the
// `ansible.builtin.template` module. Using a variable with the `content`
// parameter produces unpredictable results.
// For Windows targets, use the `ansible.windows.win_copy` module instead.
const CopyName = "copy"

// Parameters for the `copy` Ansible module.
type CopyParameters struct {
	// Local path to a file to copy to the remote server.
	// This can be absolute or relative.
	// If path is a directory, it is copied recursively. In this case, if path ends
	// with `/`, only inside contents of that directory are copied to destination.
	// Otherwise, if it does not end with `/`, the directory itself with all
	// contents is copied. This behavior is similar to the `rsync` command line
	// tool.
	Src *string `json:"src,omitempty"`

	// When used instead of `src`, sets the contents of a file directly to the
	// specified value.
	// Works only when `dest` is a file. Creates the file if it does not exist.
	// For advanced formatting or if `content` contains a variable, use the
	// `ansible.builtin.template` module.
	Content *string `json:"content,omitempty"`

	// Remote absolute path where the file should be copied to.
	// If `src` is a directory, this must be a directory too.
	// If `dest` is a non-existent path and if either `dest` ends with `/` or `src`
	// is a directory, `dest` is created.
	// If `dest` is a relative path, the starting directory is determined by the
	// remote host.
	// If `src` and `dest` are files, the parent directory of `dest` is not created
	// and the task fails if it does not already exist.
	Dest string `json:"dest"`

	// Create a backup file including the timestamp information so you can get the
	// original file back if you somehow clobbered it incorrectly.
	// default: false
	Backup *bool `json:"backup,omitempty"`

	// Influence whether the remote file must always be replaced.
	// If `true`, the remote file will be replaced when contents are different than
	// the source.
	// If `false`, the file will only be transferred if the destination does not
	// exist.
	// default: true
	Force *bool `json:"force,omitempty"`

	// The permissions of the destination file or directory.
	// For those used to `/usr/bin/chmod` remember that modes are actually octal
	// numbers. You must either add a leading zero so that Ansible's YAML parser
	// knows it is an octal number (like `0644` or `01777`) or quote it (like
	// `'644'` or `'1777'`) so Ansible receives a string and can do its own
	// conversion from string into number. Giving Ansible a number without
	// following one of these rules will end up with a decimal number which will
	// have unexpected results.
	// As of Ansible 1.8, the mode may be specified as a symbolic mode (for
	// example, `u+rwx` or `u=rw,g=r,o=r`).
	// As of Ansible 2.3, the mode may also be the special string `preserve`.
	// `preserve` means that the file will be given the same permissions as the
	// source file.
	// When doing a recursive copy, see also `directory_mode`.
	// If `mode` is not specified and the destination file `does not` exist, the
	// default `umask` on the system will be used when setting the mode for the
	// newly created file.
	// If `mode` is not specified and the destination file `does` exist, the mode
	// of the existing file will be used.
	// Specifying `mode` is the best way to ensure files are created with the
	// correct permissions. See CVE-2020-1736 for further details.
	// The permissions the resulting filesystem object should have.
	// For those used to `/usr/bin/chmod` remember that modes are actually octal
	// numbers. You must give Ansible enough information to parse them correctly.
	// For consistent results, quote octal numbers (for example, `'644'` or
	// `'1777'`) so Ansible receives a string and can do its own conversion from
	// string into number. Adding a leading zero (for example, `0755`) works
	// sometimes, but can fail in loops and some other circumstances.
	// Giving Ansible a number without following either of these rules will end up
	// with a decimal number which will have unexpected results.
	// As of Ansible 1.8, the mode may be specified as a symbolic mode (for
	// example, `u+rwx` or `u=rw,g=r,o=r`).
	// If `mode` is not specified and the destination filesystem object `does not`
	// exist, the default `umask` on the system will be used when setting the mode
	// for the newly created filesystem object.
	// If `mode` is not specified and the destination filesystem object `does`
	// exist, the mode of the existing filesystem object will be used.
	// Specifying `mode` is the best way to ensure filesystem objects are created
	// with the correct permissions. See CVE-2020-1736 for further details.
	Mode *any `json:"mode,omitempty"`

	// Set the access permissions of newly created directories to the given mode.
	// Permissions on existing directories do not change.
	// See `mode` for the syntax of accepted values.
	// The target system's defaults determine permissions when this parameter is
	// not set.
	DirectoryMode *any `json:"directory_mode,omitempty"`

	// Influence whether `src` needs to be transferred or already is present
	// remotely.
	// If `false`, it will search for `src` on the controller node.
	// If `true`, it will search for `src` on the managed (remote) node.
	// `remote_src` supports recursive copying as of version 2.8.
	// `remote_src` only works with `mode=preserve` as of version 2.6.
	// Auto-decryption of files does not work when `remote_src=yes`.
	// default: false
	RemoteSrc *bool `json:"remote_src,omitempty"`

	// This flag indicates that filesystem links in the destination, if they exist,
	// should be followed.
	// default: false
	Follow *bool `json:"follow,omitempty"`

	// This flag indicates that filesystem links in the source tree, if they exist,
	// should be followed.
	// default: true
	LocalFollow *bool `json:"local_follow,omitempty"`

	// SHA1 checksum of the file being transferred.
	// Used to validate that the copy of the file was successful.
	// If this is not provided, ansible will use the local calculated checksum of
	// the src file.
	Checksum *string `json:"checksum,omitempty"`

	// This option controls the auto-decryption of source files using vault.
	// default: true
	Decrypt *bool `json:"decrypt,omitempty"`

	// Name of the user that should own the filesystem object, as would be fed to
	// `chown`.
	// When left unspecified, it uses the current user unless you are root, in
	// which case it can preserve the previous ownership.
	// Specifying a numeric username will be assumed to be a user ID and not a
	// username. Avoid numeric usernames to avoid this confusion.
	Owner *string `json:"owner,omitempty"`

	// Name of the group that should own the filesystem object, as would be fed to
	// `chown`.
	// When left unspecified, it uses the current group of the current user unless
	// you are root, in which case it can preserve the previous ownership.
	Group *string `json:"group,omitempty"`

	// The user part of the SELinux filesystem object context.
	// By default it uses the `system` policy, where applicable.
	// When set to `_default`, it will use the `user` portion of the policy if
	// available.
	Seuser *string `json:"seuser,omitempty"`

	// The role part of the SELinux filesystem object context.
	// When set to `_default`, it will use the `role` portion of the policy if
	// available.
	Serole *string `json:"serole,omitempty"`

	// The type part of the SELinux filesystem object context.
	// When set to `_default`, it will use the `type` portion of the policy if
	// available.
	Setype *string `json:"setype,omitempty"`

	// The level part of the SELinux filesystem object context.
	// This is the MLS/MCS attribute, sometimes known as the `range`.
	// When set to `_default`, it will use the `level` portion of the policy if
	// available.
	Selevel *string `json:"selevel,omitempty"`

	// Influence when to use atomic operation to prevent data corruption or
	// inconsistent reads from the target filesystem object.
	// By default this module uses atomic operations to prevent data corruption or
	// inconsistent reads from the target filesystem objects, but sometimes systems
	// are configured or just broken in ways that prevent this. One example is
	// docker mounted filesystem objects, which cannot be updated atomically from
	// inside the container and can only be written in an unsafe manner.
	// This option allows Ansible to fall back to unsafe methods of updating
	// filesystem objects when atomic operations fail (however, it doesn't force
	// Ansible to perform unsafe writes).
	// IMPORTANT! Unsafe writes are subject to race conditions and can lead to data
	// corruption.
	// default: false
	UnsafeWrites *bool `json:"unsafe_writes,omitempty"`

	// The attributes the resulting filesystem object should have.
	// To get supported flags look at the man page for `chattr` on the target
	// system.
	// This string should contain the attributes in the same order as the one
	// displayed by `lsattr`.
	// The `=` operator is assumed as default, otherwise `+` or `-` operators need
	// to be included in the string.
	Attributes *string `json:"attributes,omitempty"`

	// The validation command to run before copying the updated file into the final
	// destination.
	// A temporary file path is used to validate, passed in through `%s` which must
	// be present as in the examples below.
	// Also, the command is passed securely so shell features such as expansion and
	// pipes will not work.
	// For an example on how to handle more complex validation than what this
	// option provides, see `handling complex
	// validation,complex_configuration_validation`.
	Validate *string `json:"validate,omitempty"`
}

// Wrap the `CopyParameters into an `rpc.RPCCall`.
func (p CopyParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := rpc.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: CopyName,
			Args: args,
		},
	}, nil
}

// Return values for the `copy` Ansible module.
type CopyReturn struct {
	AnsibleCommonReturns

	// Destination file/path.
	Dest *string `json:"dest,omitempty"`

	// Source file used for the copy on the target machine.
	Src *string `json:"src,omitempty"`

	// MD5 checksum of the file after running copy.
	Md5sum *string `json:"md5sum,omitempty"`

	// SHA1 checksum of the file after running copy.
	Checksum *string `json:"checksum,omitempty"`

	// Name of backup file created.
	BackupFile *string `json:"backup_file,omitempty"`

	// Group id of the file, after execution.
	Gid *int `json:"gid,omitempty"`

	// Group of the file, after execution.
	Group *string `json:"group,omitempty"`

	// Owner of the file, after execution.
	Owner *string `json:"owner,omitempty"`

	// Owner id of the file, after execution.
	Uid *int `json:"uid,omitempty"`

	// Permissions of the target, after execution.
	Mode *string `json:"mode,omitempty"`

	// Size of the target, after execution.
	Size *int `json:"size,omitempty"`

	// State of the target, after execution.
	State *string `json:"state,omitempty"`
}

// Unwrap the `rpc.RPCResult` into an `CopyReturn`
func CopyReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (CopyReturn, error) {
	return rpc.AnyToJSONT[CopyReturn](r.Result.Result)
}
