// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
	"github.com/sapslaj/mid/pkg/cast"
)

// Create, update and remove DNS records using DDNS updates.
const NsupdateName = "nsupdate"

// Manage DNS record.
type NsupdateState string

const (
	NsupdateStatePresent NsupdateState = "present"
	NsupdateStateAbsent  NsupdateState = "absent"
)

// Convert a supported type to an optional (pointer) NsupdateState
func OptionalNsupdateState[T interface {
	*NsupdateState | NsupdateState | *string | string
}](s T) *NsupdateState {
	switch v := any(s).(type) {
	case *NsupdateState:
		return v
	case NsupdateState:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := NsupdateState(*v)
		return &val
	case string:
		val := NsupdateState(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Specify key algorithm used by `key_secret`.
type NsupdateKeyAlgorithm string

const (
	NsupdateKeyAlgorithmHmacMd5SigAlgRegInt NsupdateKeyAlgorithm = "HMAC-MD5.SIG-ALG.REG.INT"
	NsupdateKeyAlgorithmHmacMd5             NsupdateKeyAlgorithm = "hmac-md5"
	NsupdateKeyAlgorithmHmacSha1            NsupdateKeyAlgorithm = "hmac-sha1"
	NsupdateKeyAlgorithmHmacSha224          NsupdateKeyAlgorithm = "hmac-sha224"
	NsupdateKeyAlgorithmHmacSha256          NsupdateKeyAlgorithm = "hmac-sha256"
	NsupdateKeyAlgorithmHmacSha384          NsupdateKeyAlgorithm = "hmac-sha384"
	NsupdateKeyAlgorithmHmacSha512          NsupdateKeyAlgorithm = "hmac-sha512"
)

// Convert a supported type to an optional (pointer) NsupdateKeyAlgorithm
func OptionalNsupdateKeyAlgorithm[T interface {
	*NsupdateKeyAlgorithm | NsupdateKeyAlgorithm | *string | string
}](s T) *NsupdateKeyAlgorithm {
	switch v := any(s).(type) {
	case *NsupdateKeyAlgorithm:
		return v
	case NsupdateKeyAlgorithm:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := NsupdateKeyAlgorithm(*v)
		return &val
	case string:
		val := NsupdateKeyAlgorithm(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Sets the transport protocol (TCP or UDP). TCP is the recommended and a more
// robust option.
type NsupdateProtocol string

const (
	NsupdateProtocolTcp NsupdateProtocol = "tcp"
	NsupdateProtocolUdp NsupdateProtocol = "udp"
)

// Convert a supported type to an optional (pointer) NsupdateProtocol
func OptionalNsupdateProtocol[T interface {
	*NsupdateProtocol | NsupdateProtocol | *string | string
}](s T) *NsupdateProtocol {
	switch v := any(s).(type) {
	case *NsupdateProtocol:
		return v
	case NsupdateProtocol:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := NsupdateProtocol(*v)
		return &val
	case string:
		val := NsupdateProtocol(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `nsupdate` Ansible module.
type NsupdateParameters struct {
	// Manage DNS record.
	// default: NsupdateStatePresent
	State *NsupdateState `json:"state,omitempty"`

	// Apply DNS modification on this server, specified by IPv4 or IPv6 address.
	Server string `json:"server"`

	// Use this TCP port when connecting to `server`.
	// default: 53
	Port *int `json:"port,omitempty"`

	// Use TSIG key name to authenticate against DNS `server`.
	KeyName *string `json:"key_name,omitempty"`

	// Use TSIG key secret, associated with `key_name`, to authenticate against
	// `server`.
	KeySecret *string `json:"key_secret,omitempty"`

	// Specify key algorithm used by `key_secret`.
	// default: NsupdateKeyAlgorithmHmacMd5
	KeyAlgorithm *NsupdateKeyAlgorithm `json:"key_algorithm,omitempty"`

	// DNS record will be modified on this `zone`.
	// When omitted DNS will be queried to attempt finding the correct zone.
	Zone *string `json:"zone,omitempty"`

	// Sets the DNS record to modify. When zone is omitted this has to be absolute
	// (ending with a dot).
	Record string `json:"record"`

	// Sets the record type.
	// default: "A"
	Type *string `json:"type,omitempty"`

	// Sets the record TTL.
	// default: 3600
	Ttl *int `json:"ttl,omitempty"`

	// Sets the record value.
	Value *[]string `json:"value,omitempty"`

	// Sets the transport protocol (TCP or UDP). TCP is the recommended and a more
	// robust option.
	// default: NsupdateProtocolTcp
	Protocol *NsupdateProtocol `json:"protocol,omitempty"`
}

// Wrap the `NsupdateParameters into an `rpc.RPCCall`.
func (p NsupdateParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := cast.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: NsupdateName,
			Args: args,
		},
	}, nil
}

// Return values for the `nsupdate` Ansible module.
type NsupdateReturn struct {
	AnsibleCommonReturns

	// If module has modified record.
	Changed *string `json:"changed,omitempty"`

	// DNS record.
	Record *string `json:"record,omitempty"`

	// DNS record TTL.
	Ttl *int `json:"ttl,omitempty"`

	// DNS record type.
	Type *string `json:"type,omitempty"`

	// DNS record value(s).
	Value *[]any `json:"value,omitempty"`

	// DNS record zone.
	Zone *string `json:"zone,omitempty"`

	// `dnspython` return code.
	DnsRc *int `json:"dns_rc,omitempty"`

	// `dnspython` return code (string representation).
	DnsRcStr *string `json:"dns_rc_str,omitempty"`
}

// Unwrap the `rpc.RPCResult` into an `NsupdateReturn`
func NsupdateReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (NsupdateReturn, error) {
	return cast.AnyToJSONT[NsupdateReturn](r.Result.Result)
}
