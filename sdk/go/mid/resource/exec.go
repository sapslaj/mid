// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package resource

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/sapslaj/mid/sdk/go/mid"
	"github.com/sapslaj/mid/sdk/go/mid/internal"
)

type Exec struct {
	pulumi.CustomResourceState

	Config              mid.ResourceConfigPtrOutput `pulumi:"config"`
	Connection          mid.ConnectionPtrOutput     `pulumi:"connection"`
	Create              mid.ExecCommandOutput       `pulumi:"create"`
	Delete              mid.ExecCommandPtrOutput    `pulumi:"delete"`
	DeleteBeforeReplace pulumi.BoolPtrOutput        `pulumi:"deleteBeforeReplace"`
	Dir                 pulumi.StringPtrOutput      `pulumi:"dir"`
	Environment         pulumi.StringMapOutput      `pulumi:"environment"`
	ExpandArgumentVars  pulumi.BoolPtrOutput        `pulumi:"expandArgumentVars"`
	Logging             pulumi.StringPtrOutput      `pulumi:"logging"`
	Stderr              pulumi.StringOutput         `pulumi:"stderr"`
	Stdout              pulumi.StringOutput         `pulumi:"stdout"`
	Triggers            mid.TriggersOutputOutput    `pulumi:"triggers"`
	Update              mid.ExecCommandPtrOutput    `pulumi:"update"`
}

// NewExec registers a new resource with the given unique name, arguments, and options.
func NewExec(ctx *pulumi.Context,
	name string, args *ExecArgs, opts ...pulumi.ResourceOption) (*Exec, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Create == nil {
		return nil, errors.New("invalid value for required argument 'Create'")
	}
	if args.Connection != nil {
		args.Connection = args.Connection.ToConnectionPtrOutput().ApplyT(func(v *mid.Connection) *mid.Connection { return v.Defaults() }).(mid.ConnectionPtrOutput)
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Exec
	err := ctx.RegisterResource("mid:resource:Exec", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetExec gets an existing Exec resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetExec(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ExecState, opts ...pulumi.ResourceOption) (*Exec, error) {
	var resource Exec
	err := ctx.ReadResource("mid:resource:Exec", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Exec resources.
type execState struct {
}

type ExecState struct {
}

func (ExecState) ElementType() reflect.Type {
	return reflect.TypeOf((*execState)(nil)).Elem()
}

type execArgs struct {
	Config              *mid.ResourceConfig `pulumi:"config"`
	Connection          *mid.Connection     `pulumi:"connection"`
	Create              mid.ExecCommand     `pulumi:"create"`
	Delete              *mid.ExecCommand    `pulumi:"delete"`
	DeleteBeforeReplace *bool               `pulumi:"deleteBeforeReplace"`
	Dir                 *string             `pulumi:"dir"`
	Environment         map[string]string   `pulumi:"environment"`
	ExpandArgumentVars  *bool               `pulumi:"expandArgumentVars"`
	Logging             *string             `pulumi:"logging"`
	Triggers            *mid.TriggersInput  `pulumi:"triggers"`
	Update              *mid.ExecCommand    `pulumi:"update"`
}

// The set of arguments for constructing a Exec resource.
type ExecArgs struct {
	Config              mid.ResourceConfigPtrInput
	Connection          mid.ConnectionPtrInput
	Create              mid.ExecCommandInput
	Delete              mid.ExecCommandPtrInput
	DeleteBeforeReplace pulumi.BoolPtrInput
	Dir                 pulumi.StringPtrInput
	Environment         pulumi.StringMapInput
	ExpandArgumentVars  pulumi.BoolPtrInput
	Logging             pulumi.StringPtrInput
	Triggers            mid.TriggersInputPtrInput
	Update              mid.ExecCommandPtrInput
}

func (ExecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*execArgs)(nil)).Elem()
}

type ExecInput interface {
	pulumi.Input

	ToExecOutput() ExecOutput
	ToExecOutputWithContext(ctx context.Context) ExecOutput
}

func (*Exec) ElementType() reflect.Type {
	return reflect.TypeOf((**Exec)(nil)).Elem()
}

func (i *Exec) ToExecOutput() ExecOutput {
	return i.ToExecOutputWithContext(context.Background())
}

func (i *Exec) ToExecOutputWithContext(ctx context.Context) ExecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExecOutput)
}

// ExecArrayInput is an input type that accepts ExecArray and ExecArrayOutput values.
// You can construct a concrete instance of `ExecArrayInput` via:
//
//	ExecArray{ ExecArgs{...} }
type ExecArrayInput interface {
	pulumi.Input

	ToExecArrayOutput() ExecArrayOutput
	ToExecArrayOutputWithContext(context.Context) ExecArrayOutput
}

type ExecArray []ExecInput

func (ExecArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Exec)(nil)).Elem()
}

func (i ExecArray) ToExecArrayOutput() ExecArrayOutput {
	return i.ToExecArrayOutputWithContext(context.Background())
}

func (i ExecArray) ToExecArrayOutputWithContext(ctx context.Context) ExecArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExecArrayOutput)
}

// ExecMapInput is an input type that accepts ExecMap and ExecMapOutput values.
// You can construct a concrete instance of `ExecMapInput` via:
//
//	ExecMap{ "key": ExecArgs{...} }
type ExecMapInput interface {
	pulumi.Input

	ToExecMapOutput() ExecMapOutput
	ToExecMapOutputWithContext(context.Context) ExecMapOutput
}

type ExecMap map[string]ExecInput

func (ExecMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Exec)(nil)).Elem()
}

func (i ExecMap) ToExecMapOutput() ExecMapOutput {
	return i.ToExecMapOutputWithContext(context.Background())
}

func (i ExecMap) ToExecMapOutputWithContext(ctx context.Context) ExecMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExecMapOutput)
}

type ExecOutput struct{ *pulumi.OutputState }

func (ExecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Exec)(nil)).Elem()
}

func (o ExecOutput) ToExecOutput() ExecOutput {
	return o
}

func (o ExecOutput) ToExecOutputWithContext(ctx context.Context) ExecOutput {
	return o
}

func (o ExecOutput) Config() mid.ResourceConfigPtrOutput {
	return o.ApplyT(func(v *Exec) mid.ResourceConfigPtrOutput { return v.Config }).(mid.ResourceConfigPtrOutput)
}

func (o ExecOutput) Connection() mid.ConnectionPtrOutput {
	return o.ApplyT(func(v *Exec) mid.ConnectionPtrOutput { return v.Connection }).(mid.ConnectionPtrOutput)
}

func (o ExecOutput) Create() mid.ExecCommandOutput {
	return o.ApplyT(func(v *Exec) mid.ExecCommandOutput { return v.Create }).(mid.ExecCommandOutput)
}

func (o ExecOutput) Delete() mid.ExecCommandPtrOutput {
	return o.ApplyT(func(v *Exec) mid.ExecCommandPtrOutput { return v.Delete }).(mid.ExecCommandPtrOutput)
}

func (o ExecOutput) DeleteBeforeReplace() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Exec) pulumi.BoolPtrOutput { return v.DeleteBeforeReplace }).(pulumi.BoolPtrOutput)
}

func (o ExecOutput) Dir() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Exec) pulumi.StringPtrOutput { return v.Dir }).(pulumi.StringPtrOutput)
}

func (o ExecOutput) Environment() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Exec) pulumi.StringMapOutput { return v.Environment }).(pulumi.StringMapOutput)
}

func (o ExecOutput) ExpandArgumentVars() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Exec) pulumi.BoolPtrOutput { return v.ExpandArgumentVars }).(pulumi.BoolPtrOutput)
}

func (o ExecOutput) Logging() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Exec) pulumi.StringPtrOutput { return v.Logging }).(pulumi.StringPtrOutput)
}

func (o ExecOutput) Stderr() pulumi.StringOutput {
	return o.ApplyT(func(v *Exec) pulumi.StringOutput { return v.Stderr }).(pulumi.StringOutput)
}

func (o ExecOutput) Stdout() pulumi.StringOutput {
	return o.ApplyT(func(v *Exec) pulumi.StringOutput { return v.Stdout }).(pulumi.StringOutput)
}

func (o ExecOutput) Triggers() mid.TriggersOutputOutput {
	return o.ApplyT(func(v *Exec) mid.TriggersOutputOutput { return v.Triggers }).(mid.TriggersOutputOutput)
}

func (o ExecOutput) Update() mid.ExecCommandPtrOutput {
	return o.ApplyT(func(v *Exec) mid.ExecCommandPtrOutput { return v.Update }).(mid.ExecCommandPtrOutput)
}

type ExecArrayOutput struct{ *pulumi.OutputState }

func (ExecArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Exec)(nil)).Elem()
}

func (o ExecArrayOutput) ToExecArrayOutput() ExecArrayOutput {
	return o
}

func (o ExecArrayOutput) ToExecArrayOutputWithContext(ctx context.Context) ExecArrayOutput {
	return o
}

func (o ExecArrayOutput) Index(i pulumi.IntInput) ExecOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Exec {
		return vs[0].([]*Exec)[vs[1].(int)]
	}).(ExecOutput)
}

type ExecMapOutput struct{ *pulumi.OutputState }

func (ExecMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Exec)(nil)).Elem()
}

func (o ExecMapOutput) ToExecMapOutput() ExecMapOutput {
	return o
}

func (o ExecMapOutput) ToExecMapOutputWithContext(ctx context.Context) ExecMapOutput {
	return o
}

func (o ExecMapOutput) MapIndex(k pulumi.StringInput) ExecOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Exec {
		return vs[0].(map[string]*Exec)[vs[1].(string)]
	}).(ExecOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ExecInput)(nil)).Elem(), &Exec{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExecArrayInput)(nil)).Elem(), ExecArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExecMapInput)(nil)).Elem(), ExecMap{})
	pulumi.RegisterOutputType(ExecOutput{})
	pulumi.RegisterOutputType(ExecArrayOutput{})
	pulumi.RegisterOutputType(ExecMapOutput{})
}
