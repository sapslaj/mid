// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
	"github.com/sapslaj/mid/pkg/cast"
)

// Apply patch files using the GNU patch tool.
const PatchName = "patch"

// Whether the patch should be applied or reverted.
type PatchState string

const (
	PatchStateAbsent  PatchState = "absent"
	PatchStatePresent PatchState = "present"
)

// Convert a supported type to an optional (pointer) PatchState
func OptionalPatchState[T interface {
	*PatchState | PatchState | *string | string
}](s T) *PatchState {
	switch v := any(s).(type) {
	case *PatchState:
		return v
	case PatchState:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := PatchState(*v)
		return &val
	case string:
		val := PatchState(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `patch` Ansible module.
type PatchParameters struct {
	// Path of a base directory in which the patch file will be applied.
	// May be omitted when `dest` option is specified, otherwise required.
	Basedir *string `json:"basedir,omitempty"`

	// Path of the file on the remote machine to be patched.
	// The names of the files to be patched are usually taken from the patch file,
	// but if there's just one file to be patched it can specified with this
	// option.
	Dest *string `json:"dest,omitempty"`

	// Path of the patch file as accepted by the GNU patch tool. If
	// `remote_src=false`, the patch source file is looked up from the module's
	// `files` directory.
	Src string `json:"src"`

	// Whether the patch should be applied or reverted.
	// default: PatchStatePresent
	State *PatchState `json:"state,omitempty"`

	// If `false`, it will search for src at originating/controller machine,
	// If `true`, it will go to the remote/target machine for the `src`.
	// default: false
	RemoteSrc *bool `json:"remote_src,omitempty"`

	// Number that indicates the smallest prefix containing leading slashes that
	// will be stripped from each file name found in the patch file.
	// For more information see the strip parameter of the GNU patch tool.
	// default: 0
	Strip *int `json:"strip,omitempty"`

	// Passes `--backup --version-control=numbered` to patch, producing numbered
	// backup copies.
	// default: false
	Backup *bool `json:"backup,omitempty"`

	// Setting to `true` will disable patch's heuristic for transforming CRLF line
	// endings into LF.
	// Line endings of `src` and `dest` must match.
	// If set to `false`, `patch` will replace CRLF in `src` files on POSIX.
	// default: false
	Binary *bool `json:"binary,omitempty"`

	// Setting to `true` will ignore white space changes between patch and input.
	// default: false
	IgnoreWhitespace *bool `json:"ignore_whitespace,omitempty"`
}

// Wrap the `PatchParameters into an `rpc.RPCCall`.
func (p PatchParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := cast.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: PatchName,
			Args: args,
		},
	}, nil
}

// Return values for the `patch` Ansible module.
type PatchReturn struct {
	AnsibleCommonReturns
}

// Unwrap the `rpc.RPCResult` into an `PatchReturn`
func PatchReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (PatchReturn, error) {
	return cast.AnyToJSONT[PatchReturn](r.Result.Result)
}
