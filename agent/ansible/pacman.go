// Code generated by ./hack/generate-ansible-types.py DO NOT EDIT
package ansible

import (
	"github.com/sapslaj/mid/agent/rpc"
)

// Manage packages with the `pacman` package manager, which is used by Arch
// Linux and its variants.
const PacmanName = "pacman"

// Whether to install (`present` or `installed`, `latest`), or remove (`absent`
// or `removed`) a package.
// `present` and `installed` will simply ensure that a desired package is
// installed.
// `latest` will update the specified package if it is not of the latest
// available version.
// `absent` and `removed` will remove the specified package.
type PacmanState string

const (
	PacmanStateAbsent    PacmanState = "absent"
	PacmanStateInstalled PacmanState = "installed"
	PacmanStateLatest    PacmanState = "latest"
	PacmanStatePresent   PacmanState = "present"
	PacmanStateRemoved   PacmanState = "removed"
)

func OptionalPacmanState[T interface {
	*PacmanState | PacmanState | *string | string
}](s T) *PacmanState {
	switch v := any(s).(type) {
	case *PacmanState:
		return v
	case PacmanState:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := PacmanState(*v)
		return &val
	case string:
		val := PacmanState(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// The install reason to set for the packages.
type PacmanReason string

const (
	PacmanReasonDependency PacmanReason = "dependency"
	PacmanReasonExplicit   PacmanReason = "explicit"
)

func OptionalPacmanReason[T interface {
	*PacmanReason | PacmanReason | *string | string
}](s T) *PacmanReason {
	switch v := any(s).(type) {
	case *PacmanReason:
		return v
	case PacmanReason:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := PacmanReason(*v)
		return &val
	case string:
		val := PacmanReason(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Set the install reason for `all` packages or only for `new` packages.
// In case of `state=latest` already installed packages which will be updated to
// a newer version are not counted as `new`.
type PacmanReasonFor string

const (
	PacmanReasonForAll PacmanReasonFor = "all"
	PacmanReasonForNew PacmanReasonFor = "new"
)

func OptionalPacmanReasonFor[T interface {
	*PacmanReasonFor | PacmanReasonFor | *string | string
}](s T) *PacmanReasonFor {
	switch v := any(s).(type) {
	case *PacmanReasonFor:
		return v
	case PacmanReasonFor:
		return &v
	case *string:
		if v == nil {
			return nil
		}
		val := PacmanReasonFor(*v)
		return &val
	case string:
		val := PacmanReasonFor(v)
		return &val
	default:
		panic("unsupported type")
	}
}

// Parameters for the `pacman` Ansible module.
type PacmanParameters struct {
	// Name or list of names of the package(s) or file(s) to install, upgrade, or
	// remove. Cannot be used in combination with `upgrade`.
	Name *[]string `json:"name,omitempty"`

	// Whether to install (`present` or `installed`, `latest`), or remove (`absent`
	// or `removed`) a package.
	// `present` and `installed` will simply ensure that a desired package is
	// installed.
	// `latest` will update the specified package if it is not of the latest
	// available version.
	// `absent` and `removed` will remove the specified package.
	// default: PacmanStatePresent
	State *PacmanState `json:"state,omitempty"`

	// When removing packages, forcefully remove them, without any checks. Same as
	// `extra_args="--nodeps --nodeps"`.
	// When combined with `update_cache`, force a refresh of all package databases.
	// Same as `update_cache_extra_args="--refresh --refresh"`.
	// default: false
	Force *bool `json:"force,omitempty"`

	// When removing packages, do not save modified configuration files as
	// `.pacsave` files. (passes `--nosave` to pacman).
	// default: false
	RemoveNosave *bool `json:"remove_nosave,omitempty"`

	// Path of the binary to use. This can either be `pacman` or a pacman
	// compatible AUR helper.
	// Pacman compatibility is unfortunately ill defined, in particular, this
	// modules makes extensive use of the `--print-format` directive which is known
	// not to be implemented by some AUR helpers (notably, `yay`).
	// Beware that AUR helpers might behave unexpectedly and are therefore not
	// recommended.
	// default: "pacman"
	Executable *string `json:"executable,omitempty"`

	// Additional option to pass to pacman when enforcing `state`.
	// default: ""
	ExtraArgs *string `json:"extra_args,omitempty"`

	// Whether or not to refresh the master package lists.
	// This can be run as part of a package installation or as a separate step.
	// If not specified, it defaults to `false`.
	// Please note that this option only had an influence on the module's `changed`
	// state if `name` and `upgrade` are not specified before community.general
	// 5.0.0. See the examples for how to keep the old behavior.
	UpdateCache *bool `json:"update_cache,omitempty"`

	// Additional option to pass to pacman when enforcing `update_cache`.
	// default: ""
	UpdateCacheExtraArgs *string `json:"update_cache_extra_args,omitempty"`

	// Whether or not to upgrade the whole system. Cannot be used in combination
	// with `name`.
	// If not specified, it defaults to `false`.
	Upgrade *bool `json:"upgrade,omitempty"`

	// Additional option to pass to pacman when enforcing `upgrade`.
	// default: ""
	UpgradeExtraArgs *string `json:"upgrade_extra_args,omitempty"`

	// The install reason to set for the packages.
	Reason *PacmanReason `json:"reason,omitempty"`

	// Set the install reason for `all` packages or only for `new` packages.
	// In case of `state=latest` already installed packages which will be updated
	// to a newer version are not counted as `new`.
	// default: PacmanReasonForNew
	ReasonFor *PacmanReasonFor `json:"reason_for,omitempty"`
}

// Wrap the `PacmanParameters into an `rpc.RPCCall`.
func (p *PacmanParameters) ToRPCCall() (rpc.RPCCall[rpc.AnsibleExecuteArgs], error) {
	args, err := rpc.AnyToJSONT[map[string]any](p)
	if err != nil {
		return rpc.RPCCall[rpc.AnsibleExecuteArgs]{}, err
	}
	return rpc.RPCCall[rpc.AnsibleExecuteArgs]{
		RPCFunction: rpc.RPCAnsibleExecute,
		Args: rpc.AnsibleExecuteArgs{
			Name: PacmanName,
			Args: args,
		},
	}, nil
}

// Return values for the `pacman` Ansible module.
type PacmanReturn struct {
	AnsibleCommonReturns

	// A list of packages that have been changed.
	// Before community.general 4.5.0 this was only returned when `upgrade=true`.
	// In community.general 4.5.0, it was sometimes omitted when the package list
	// is empty, but since community.general 4.6.0 it is always returned when
	// `name` is specified or `upgrade=true`.
	Packages *[]string `json:"packages,omitempty"`

	// The changed status of `pacman -Sy`.
	// Useful when `name` or `upgrade=true` are specified next to
	// `update_cache=true`.
	CacheUpdated *bool `json:"cache_updated,omitempty"`

	// Output from pacman.
	Stdout *string `json:"stdout,omitempty"`

	// Error output from pacman.
	Stderr *string `json:"stderr,omitempty"`
}

// Unwrap the `rpc.RPCResult` into an `PacmanReturn`
func PacmanReturnFromRPCResult(r rpc.RPCResult[rpc.AnsibleExecuteResult]) (PacmanReturn, error) {
	return rpc.AnyToJSONT[PacmanReturn](r.Result.Result)
}
